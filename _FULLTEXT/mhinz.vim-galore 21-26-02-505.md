chinese japanese portuguese russian licensed under cc by sa 4 0 intro what is vim the vim philosophy first steps minimal vimrc what kind of vim am i running cheatsheets basics buffers windows tabs active loaded listed named buffers argument list mappings mapleader registers ranges marks completion motions operators text objects autocmds changelist jumplist undo tree quickfix and location lists macros colorschemes folding sessions locality usage getting help offline getting help offline alternative getting help online autocmds in practice user events nested autocmds clipboard clipboard usage windows macos clipboard usage linux bsd restore cursor position when opening file temporary files backup files swap files undo files viminfo files example configuration for temporary files editing remote files managing plugins block insert running external programs and using filters cscope matchit true colors tips saner behavior of n and n saner command line history saner ctrl l disable audible and visual bells quickly move current line quickly add empty lines quickly edit your macros quickly jump to header or source file quickly change font size in gui change cursor style dependent on mode dont lose selection when shifting sidewards reload a file on saving smarter cursorline faster keyword completion cosmetic changes to colorschemes commands global and vglobal execute a command on all matching lines normal and execute the scripting dream team redir and execute capture command output debugging general tips verbosity profiling startup time profiling at runtime debugging vim scripts debugging syntax files miscellaneous additional resources vim distributions standard plugins map capslock to control easter eggs why hjkl for navigation common problems editing small files is slow editing huge files is slow bracketed paste or why do i have to set paste all the time delays when using escape key in terminal function search undo technical quirks newline used for nul list of colorschemes list of plugins intro what is vim vim is a text editor with a long line of ancestors that goes back to qed bram moolenaar released it in 1991 the project is hosted online at vim org getting vim use your favourite package manager or visit the download page from vim org discussions and user questions are best done on the vim use mailing list or using irc freenode in the vim channel development happens on github discussions on the vim dev mailing list read why oh why do those nutheads use vi to see common misconceptions about vim explained the vim philosophy vim adheres to the modal editing philosophy this means that it provides multiple modes and the meaning of keys changes according to the mode you navigate files in normal mode you insert text in insert mode you select lines in visual mode you access commands in command line mode and so on this might sound complicated at first but has a huge advantage you dont have to break your fingers by holding several keys at once most of the time you simply press them one after the other the more common the task the fewer keys are needed a related concept that works well with modal editing are operators and motions operators start a certain action e g changing removing or selecting text afterwards you specify the region of text you want to act on using a motion to change everything between parentheses use ci read change inner parentheses to remove an entire paragraph of text use dap read delete around paragraph if you see advanced vim users working youll notice that they speak the language of vim as well as pianists handle their instruments complex operations are done using only a few key presses they dont even think about it anymore as muscle memory took over already this reduces cognitive load and helps to focus on the actual task first steps vim comes bundled with an interactive tutorial that teaches the most basic things you need to know about you can start it from the shell vimtutor dont be put off by how boring it looks like and work through the exercises the editors or ides you used before were most probably all non modal so working by switching modes will seem awkward at first but the more you use vim the more it becomes muscle memory vim was bolted on stevie a vi clone and supports two operating modes compatible and nocompatible using vim in compatible mode means using vi defaults for all options opposed to vim defaults as long as you didnt create a user vimrc yet or started vim with vim n compatible mode is assumed dont use vim in compatible mode just dont next steps create your own vimrc have some cheatsheets ready for the first weeks read through the basics section to learn what is even possible learn on demand you never finish learning vim if you encounter any problems just look for it on the internet your problem was solved already vim comes with great documentation and knowing how to navigate it is a must getting help offline have a look at the additional resources one last advice please learn how to use vim properly before starting to add all kinds of hyped plugins that only implement features that vim already supports natively minimal vimrc the user vimrc can be put into vimrc or for the sake of better separation into vim vimrc the latter makes it easy to put the entire configuration under version control and upload it to lets say github you find many minimal vimrcs all over the net and maybe my version isnt as minimal as it should be but it provides a good set of sane settings that i deem to be useful for starting out eventually you have to read up on all the mentioned settings anyway and decide for yourself so here it is minimal vimrc in case youre interested heres my vimrc tip most plugin authors maintain several plugins and also publish their vimrc on github often in a repository called vim config or dotfiles so whenever you find a plugin you like look up its maintainers github page and look through the repositories what kind of vim am i running looking at version will give you all the information you need to know about how the currently running vim binary was compiled the first line tells you when the binary was compiled and the version e g 7 4 one of the next lines states included patches 1 1051 which is the patch level thus your exact vim version is 7 4 1051 another line states something like tiny version without gui or huge version with gui the obvious information from that is whether your vim includes gui support e g for starting gvim from the shell or running gui from vim within a terminal emulator the other important information is the tiny and huge vim distinguishes between feature sets called tiny small normal big and huge all enabling different subsets of features the majority of version output is consumed by the feature list itself clipboard means the clipboard feature was compiled in clipboard means it wasnt compiled in a few vim features need to be compiled in for them to work e g for prof to work you need a vim with a huge feature set because that set enables the profile feature if thats not the case and you installed vim from a package manager make sure to install a package called vim x vim x11 vim gtk vim gnome or similar since these packages usually come with the huge feature set you can also test for the version or features programmatically vim do something if running at least vim 7 4 42 with profile enabled if v version 704 v version 704 has patch42 has profile do stuff endif help h version h feature list h feature list h has patch cheatsheets http people csail mit edu vgod vim vim cheat sheet en png https cdn shopify com s files 1 0165 4168 files preview png http www nathael org data vi vim cheat sheet svg http michael peopleofhonoronly com vim vim cheat sheet for programmers screen png http www rosipov com images posts vim movement commands cheatsheet png or quickly open a cheatsheet from within vim vim cheat40 basics buffers windows tabs vim is a text editor every time text is shown the text is part of a buffer each file will be opened in its own buffer plugins show stuff in their own buffers etc buffers have many attributes e g whether the text it contains is modifiable or whether it is associated with a file and thus needs to be synchronized to disk on saving windows are viewports onto buffers if you want to view several files at the same time or even different locations of the same file you use windows and please please dont call them splits you can split a window in two but that doesnt make them splits windows can be split vertically or horizontally and the heights and widths of existing windows can be altered too therefore you can use whatever window layout you prefer a tab page or just tab is a collection of windows thus if you want to use multiple window layouts use tabs putting it in a nutshell if you start vim without arguments youll have one tab page that holds one window that shows one buffer by the way the buffer list is global and you can access any buffer from any tab active loaded listed named buffers run vim like this vim file1 the files content will be loaded into a buffer you have a loaded buffer now the content of the buffer is only synchronized to disk written back to the file if you save it within vim since the buffer is also shown in a window its also an active buffer now if you load another file via e file2 file1 will become a hidden buffer and file2 the active one both buffers are also listed thus they will get listed in the output of ls plugin buffers or help buffers are often marked as unlisted since theyre not regular files you usually edit with a text editor listed and unlisted buffers can be shown via ls unnamed buffers also often used by plugins are buffers that dont have an associated filename e g enew will create an unnamed scratch buffer add some text and write it to disk via w tmp foo and it will become a named buffer argument list the global buffer list is a vim thing before that in vi there only used to be the argument list which is also available in vim every filename given to vim on the shell command line is remembered in the argument list there can be multiple argument lists by default all arguments are put into the global argument list but you can use arglocal to create a new argument list that is local to the window list the current arguments with args switch between files from the argument list with next previous first last and friends alter it with argadd argdelete or args with a list of files if you should prefer using the buffer or argument list for working with files is a matter of taste my impression is that most people use the buffer list exclusively nevertheless there is one huge use case for the argument list batch processing via argdo a simple refactoring example vim args ch argdo s foo bar ge update this replaces all occurrences of foo by bar in all c source and header files from the current directory and below help h argument list mappings you can define your own mappings with the map family of commands each command of that family defines a mapping for a certain set of modes technically vim comes with a whopping 12 modes 6 of them can be mapped additionally some commands act on multiple modes at once recursive non recursive unmap modes map noremap unmap normal visual operator pending nmap nnoremap nunmap normal xmap xnoremap xunmap visual cmap cnoremap cunmap command line omap onoremap ounmap operator pending imap inoremap iunmap insert e g this defines the mapping for normal mode only vim nmap space echo foo cr unmap it again by using nunmap space for a few more but rather uncommon modes or combinations of them see h map modes so far so good theres only one problem that can be pretty confusing to beginners nmap is recursive that is the right hand side takes other mappings into account so you defined a mapping that simply echoes foo vim nmap b echo foo cr but what if you want to map the default behavior of b going one word back to another key vim nmap a b if you hit a we expect the cursor to go back a word but instead foo is printed in the command line because the right hand side b was mapped to another action already namely echo foo cr the proper way to resolve this problem is to use a non recursive mapping instead vim nnoremap a b rule of thumb always use non recursive mappings unless recursing is actually desired look up your mappings by not giving a right hand side e g nmap shows all normal mappings and nmap leader shows all normal mappings that start with the mapleader if you want to disable a standard mapping map them to the special nop character e g noremap left nop help h key notation h mapping h 05 3 mapleader the mapleader is simply a placeholder than can be used with custom mappings and is set to \ by default vim nnoremap leader h helpgrep space this mapping is triggered by \h if you want to use space h instead vim let mapleader nnoremap leader h helpgrep space moreover there is localleader that is the local counterpart to leader and is supposed to be used for mappings that are local to the buffer eg filetype specific plugins it also defaults to \ note set the mapleaders before mappings all leader mappings that are in effect already wont change just because the mapleader was changed nmap leader will show all normal mode leader mappings with the mapleader resolved already so use it to double check your mappings see h mapleader and h maplocalleader for more registers registers are slots that save text copying text into a register is called yanking and extracting text from a register is called pasting vim provides the following registers type character filled by readonly contains text from unnamed vim last yank or deletion d c s x y numbered 0 to 9 vim register 0 last yank register 1 last deletion register 2 second last deletion and so on think of registers 1 9 as a read only queue with 9 elements small delete vim last deletion that was less than one line named a to z a to z user if you yank to register a you replace its text if you yank to register a you append to the text in register a read only vim x last command last inserted text current filename alternate buffer vim most of the time the previously visited buffer of the current window see h alternate file expression user evaluation of the viml expression that was yanked e g do this in insert mode c r 5 5 cr and 10 will be inserted in the buffer selection vim and are the clipboard registers drop vim x from last dragndrop black hole vim if you dont want any other registers implicitly affected e g dd deletes the current line without affecting registers 1 last search pattern vim last pattern used with global etc each register that is not readonly can be set by the user vim let register afterwards n would jump to the next occurrence of register there are numerous exceptions when registers get implicitly filled so be sure to read h registers yank with y and paste with p p but mind that vim distinguishes between characterwise and linewise visual selections see h linewise example linewise yy or just y yanks the current line move the cursor somewhere else use p to paste below the current line p for pasting above it example charwise yank the first word with 0yw move somewhere else paste after the cursor on the current line with p and before the cursor with p example explicit naming of register ay yanks the current line into register a move to another line ay appends the current line to register a i suggest playing around with all these registers a bit and constantly checking reg so you can see whats actually happening fun fact in emacs yanking stands for pasting or reinserting previously killed text not copying ranges ranges are pretty easy to understand but many vimmers dont know about their full potential many commands take ranges an address denotes a certain line a range is either a single address or a pair of addresses separated by either or ranges tell commands which lines to act on most commands act only on the current line by default notable exceptions are write and global which act on all lines the usage of ranges is pretty intuitive so here are some examples using d as short form of delete command lines acted on d current line d current line 1d first line d last line 1 d all lines d all lines syntactic sugar for 1 5d current line to line 5 5d also current line to line 5 3d current line and the next 3 lines 1 3d first line to current line 3 3d current line and the last 3 lines vim will prompt you since this is a reversed range 3 xdelete lines 3 to the line marked by mark x foo delete from the next line that starts with foo to the end foo 1 delete from the line after the line that starts with foo to the end note that instead of can be used as a separator the difference is that in the case of from to the to is relative to the current line but when using from to the to is relative to the address of from assuming youre on line 5 1 1d would delete lines 1 to 6 whereas 1 1d would only delete lines 1 and 2 the address can be preceded with another address this allows you to stack patterns e g vim foo bar quux d this would delete the first line containing quux after the first line containing bar after the first line containing foo after the current line sometimes vim automatically prepends the command line with a range e g start a visual line selection with v select some lines and type the command line will be populated with the range which means the following command will use the previously selected lines as a range this is also why you sometimes see mappings like vnoremap foo c u command here c u is used to remove the range because vim will throw an error when giving a range to a command that doesnt support it another example is using in normal mode this will populate the command line with if followed by an external program that programs output would replace the current line so you could replace the current paragraph with the output of ls by using 1 1 ls fancy help h cmdline ranges h 10 3 marks you use marks to remember a position that is line number and column in a file marks set by usage a z user local to file thus only valid within one file jumping to a lowercase mark means jumping within the current file a z user global thus valid between files also called file marks jumping to a file mark may switch to another buffer 0 9 viminfo 0 is the position when the viminfo file was written last in practice this means when the last vim process ended 1 is the position of when the second last vim process ended and so on put g or g in front of a mark to form a motion use mm to remember the current position with mark m move around the file and then jump back via m first non blank or m exact column lowercase marks will be remembered after exiting vim if you tell your viminfo file to do so see h viminfo use mm to remember the current position with file mark m switch to another buffer and switch back via m or m other motions include motion jump to first line or character of previously changed or yanked text last line or character of previously changed or yanked text beginning line or character of last visual selection ending line or character of last visual selection position before the latest jump position when last exiting the current buffer position where last insertion stopped position where last change was made start of current sentence end of current sentence start of current paragraph end of current paragraph marks can also be used in a range you probably saw this before and wondered what it means select some text in visual mode and do the command line will be prepended with which means the following command would get a range that denotes the visual selection use marks to list all marks read everything in h mark motions completion vim provides many kinds of insert mode completions if there are multiple matches a popup menu will let you navigate to the match of your choice typical kinds of completion are tags functions from imported modules or libraries file names dictionary or simply words from the current buffer vim provides a mapping for each kind of completion and they all start with c x remember to use them in insert mode mapping kind help c x c l whole lines h i x l c x c n keywords from current file h i x n c x c k keywords from dictionary option h i x k c x c t keywords from thesaurus option h i x t c x c i keywords from current and included files h i x i c x c tags h i x c x c f file names h i x f c x c d definitions or macros h i x d c x c v vim commands h i x v c x c u user defined as specified in completefunc h i x u c x c o omni completion as specified in omnifunc h i x o c x s spelling suggestions h i xs people might be confused about the difference between user defined completion and omni completion but technically they do the same thing they take a function that inspects the current position and return a list of suggestions user defined completion is defined by the user for their own personal purposes surprise it could be anything omni completion is meant for filetype specific purposes like completing struct members or class methods and is often set by filetype plugins vim also allows for completing multiple kinds at once by setting the complete option by default that option includes quite a lot so be sure to trim it to your taste you can trigger this completion by using either c n next and c p previous which also happen to be the keys used for choosing entries in the popup menu see h i n and h complete for more on this be sure to check out h completeopt for configuring the behaviour of the popup menu the default is quite sane but i prefer adding noselect as well help h ins completion h popupmenu keys h new omni completion motions operators text objects motions move the cursor you all know h j k l or w and b even is a motion they also take a count 2 the cr jumps to the second last occurrence of the see h navigation and everything below for all available motions operators act on a region of text e g d gu to name just a few they get used in two contexts either in normal or visual mode in normal mode operators come first followed by a motion e g j in visual mode operators simply act on the selection e g vjd like motions operators take a count e g 2guw makes the rest of the current word and the next one uppercase since motions and operators take counts 2gu2w works just as well and executes gu2w twice see h operator for all available operators use set tildeop to make act as an operator text objects act on the surrounding area opposed to motions that act into one direction actually they work on objects e g a whole word a whole sentence everything between parentheses and so on text objects cant be used to move the cursor in normal mode because even the most skilled cursors cant jump into two directions at the same time it works in visual mode though because then one side of the object is already selected and the cursor simply jumps to the other side text objects start with either i think inner or a think around followed by a character denoting the object with i it only acts on the object itself with a on the object plus trailing whitespace e g diw deletes the current word and ci changes everything between parentheses text objects take a count imagine and the cursor on or between the most inner parentheses then d2a will remove the 2 inner pairs of parentheses and everything in between see h text objects for all available text objects autocmds on many occasions vim emits events you hook into these events by using autocmds you wouldnt use vim if there werent autocmds theyre used all the time even if you dont notice it dont believe me check au but dont let the output overwhelm you these are all the autocmds that are in effect right now see h event for a quick overview of all available events and h autocmd events abc for more details a typical example would be setting filetype specific settings vim autocmd filetype ruby setlocal shiftwidth 2 softtabstop 2 comments but how does a buffer even know that it contains ruby code because another autocmd detected it as that and set the filetype accordingly which again triggered the filetype event one of the first things everyone adds to their vimrc is filetype on this simply means that filetype vim is read at startup which sets autocmds for almost all filetypes under the sun if youre brave enough have a look at it e vimruntime filetype vim search for ruby and youll find that vim simply uses the file extension rb to detect ruby files note autocmds of the same event are executed in the order they were created au shows them in the correct order vim au bufnewfile bufread rb rbw setf ruby the bufnewfile and bufread events in this case are hardcoded in the c sources of vim and get emitted everytime you open a file via e and similar commands afterwards all the hundreds of filetypes from filetype vim are tested for putting it in a nutshell vim makes heavy use of events and autocmds but also exposes a clean interface to hook into that event driven system for customization help h autocommand changelist jumplist the positions of the last 100 changes are kept in the changelist several small changes on the same line will be merged together but the position will be that of the last change nevertheless in case you added something in the middle of the line every time you jump the position before the jump is remembered in the jumplist a jumplist has up to 100 entries each window has its own jumplist when you split a window the jumplist is copied a jump is one of the following commands g n n s tag l m h and commands that start editing a new file list list all entries go to older position go to newer position jumplist jumps count c o count c i changelist changes count g count g when you list all entries a marker will be used to show the current position usually that will be below position 1 the latest position if you want both lists to persist after restarting vim you need to use the viminfo file and h viminfo note the position before the latest jump is also kept as a mark and can be jumped to via or help h changelist h jumplist undo tree the latest changes to the text state are remembered you can use undo to revert changes and redo to reapply previously reverted changes the important bit to understand it that the data structure holding recent changes is not a queue but a tree your changes are nodes in the tree and each but the top node has a parent node each node keeps information about the changed text and time a branch is a series of nodes that starts from any node and goes up to the top node new branches get created when you undo a change and then insert something else ifoo esc obar esc obaz esc u oquux esc now you have 3 lines and the undo tree looks like this foo 1 bar 2 \ baz 3 quux 4 the undo tree has 4 changes the numbers represent the time the nodes were created now there are two ways to traverse this tree lets call them branch wise and time wise undo u and redo c r work branch wise they go up and down the current branch u will revert the text state to the one of node bar another u will revert the text state even further to the one of node foo now c r goes back to the state of node bar and another c r to the state of node quux theres no way to reach node baz using branch wise commands anymore opposed to this g and g work time wise thus g wont revert to the state of node bar like u does but to the chronologically previous state node baz another g would revert the state to the one of node bar and so on thus g and g simply go back and forth in time respectively command mapping action count u undo count undo count changes count c r redo redo count changes u undo all changes to the line of the latest change count g earlier count go to older text state count times the can be either s m h d or f e g earlier 2d goes to the text state from 2 days ago earlier 1f will go to the state of the latest file save count g later count same as above but other direction the undo tree is kept in memory and will be lost when vim quits see undo files for how to enable persistent undo if youre confused by the undo tree undotree does a great job at visualizing it help h undo txt h usr 32 quickfix and location lists the quickfix list is a data structure that holds file positions essentially each entry in the quickfix list consists of a file path a line number and optional column and a description typical use cases are assembling compiler errors or results of a grep tool vim has a special type of buffer for showing the quickfix list the quickfix buffer each line in the quickfix buffer shows one entry from the quickfix list usually you open a new window to display the quickfix list the quickfix window when that happens the last window gets associated with the quickfix window in the quickfix buffer cr opens the selected entry in the associated window and c w cr in a new window the quickfix list was named after the quick fix feature from the aztec c compiler actually there are two kinds of lists quickfix and location lists they behave almost the same but have the follwing differences there is only one quickfix list there can be multiple location lists one per window they use slightly different commands for navigation action quickfix location open window copen lopen close window cclose lclose next entry cnext lnext previous entry cprevious lprevious first entry cfirst lfirst last entry clast llast mind that the quickfix and location windows dont need to be open for these commands to work see h quickfix for more information and a full list of commands for conciseness quickfix and location are often abbreviated as qf and loc respectively example let us use our good old friend grep for searching the files in the current directory recursively for a certain query and put the results in the quickfix list vim let grepprg grep rn grep foo grep output hit enter copen assuming any files contained the string foo it should be shown now in the quickfix window macros vim allows recording typed characters into a register its a great way to automate certain tasks on the fly for more elaborate tasks vim scripting should be used instead start recording by typing q followed by the register e g q the command line will signify this via recording q stop recording by hitting q once again execute the macro via count q repeat the last used macro via count example 1 insert a line and repeat it 10 times qq iabc cr esc q 10 q the same could be done without macros oabc esc 10 example 2 for adding line numbers in front of all lines start on the first line and add 1 to it manually increment the number under the cursor by using c a displayed as a qq 0yf jp0 a q 1000 q here we simply hope that the file doesnt contain more than 1000 lines when using 1000 q but we can also use a recursive macro which executes until the macro cant be applied to a line anymore qq 0yf jp0 a q q q the same could be done without macros s \ line mind that i also show how to achieve the same without using macros but this mostly works only for such simple examples for more complex automation macros are the bomb also see quickly edit your macros help h recording h lazyredraw colorschemes colorschemes are the way to style your vim vim consists of many components and each of those can be customized with different colors for the foreground background and a few other attributes like bold text etc they can be set like this vim highlight normal ctermbg 1 guibg red this would paint the background of the editor red see h highlight for more information so colorschemes are mostly collections of highlight commands actually most colorschemes are really 2 colorschemes the example above sets colors via ctermbg and guibg the former definition cterm will only be used if vim was started in a terminal emulator e g xterm the latter gui will be used in graphical environments like gvim or macvim if you ever happen to use a colorscheme in terminal vim and the colors dont look like the ones in the screenshot at all chances are that the colorscheme only defines colors for the gui conversely if you use a graphical vim e g gvim or macvim and the colors look off the colorscheme might only define colors for the terminal the latter case can be solved by enabling true colors in neovim or vim 7 4 1830 and newer this makes terminal vim use the gui definitions instead but also requires the terminal emulator itself and all software in between e g tmux to be capable of handling true colors this gist gives a good overview about the topic help h termguicolors list of colorschemes cosmetic changes to colorschemes folding every text or source code has a certain structure if you have a structure it means you have regions of logically separated text folding allows to fold such a region into a single line and displaying a short description there are many commands that act on these regions called folds folds can be nested vim distinguishes between several types of fold methods foldmethod usage diff used in diff windows to fold unchanged text expr uses foldexpr to basically create a new fold method indent folds based on indentation manual create folds yourself via zf zf and fold marker folds based on markers in the text often in comments syntax folds based on syntax e g folding if blocks note folding can be computationally intensive if you experience any performance drawbacks small delays when typing have a look at fastfold which prevents vim from updating folds when its not needed help h usr 28 h folds sessions if you save a view h mkview the current state of the window and options and mappings gets saved for later use h loadview a session saves the views of all windows plus global settings it basically makes a snapshot of your current vim instance and saves it in a session file let me stress this it saves the current state everything done after saving a session wont be part of the session file to update a session simply write it out again this makes it perfect for saving your projects and easy to switch between them try it right now open a few windows and tabs and do mksession foo vim if you omit the filename session vim will be assumed the file will be saved to the current working directory check pwd restart vim and do source foo vim and voil√† the buffer list window layout mappings working directory etc should all be the same as before you saved the session do some more work and update the session by overwriting the already existing session file with mksession foo vim note that a session file is really just a collection of vim commands that are supposed to restore a certain state of a vim instance so feel free to take a look at it vs foo vim you can tell vim what things to save in a session by setting sessionoptions for scripting purposes vim keeps the name of the last sourced or written session in the internal variable v this session help h session h sessionoptions h v this session locality many of the concepts mentioned above also have local counterparts global local scope help set setlocal buffer or window h local options map map buffer buffer h map local autocmd autocmd buffer buffer h autocmd buflocal cd lcd window h lcd leader localleader buffer h maplocalleader variables also have different scopes usage getting help offline vim comes with great documentation in the form of single text files with a special layout vim uses a system based on tags for accessing certain parts of those help files first of all read this help help this will open the file vimruntime doc helphelp txt in a new window and jump to the help tag within that file a few simple rules options are enclosed in single quotes e g h textwidth viml functions end in e g h reverse commands start with e g h echo you can use c d this is ctrl d to list all tags that match the currently entered query e g h tab c d will get you a list of all tags from tab over softtabstop to setting guitablabel you want to list all viml functions simple h c d you want to list all viml functions that concern windows h win c d this quickly becomes second nature but especially in the beginning you sometimes dont know any part of the tag you are looking for you can only imagine some keywords that could be involved helpgrep to the rescue helpgrep backwards this will look for backwards in all documentation files and jump to the first match the matches will be assembled in the quickfix list use cn cp to jump to the next previous match or use copen to open the quickfix window navigate to an entry and hit cr to jump to that match see h quickfix for the whole truth getting help offline alternative this list was compiled by chrisbra one of the most active vim developers and posted to vim dev its reposted here with minor changes if you know what you are looking for it is usually easier to search for it using the help system because the subjects follow a certain style guide also the help has the advantage of belonging to your particular vim version so that obsolete topics or topics that have been added later wont turn up therefore it is essential to learn the help system and the language it uses here are some examples not necessarily complete and i might have forgotten something options are enclosed in single quotes so you would use h list to go to the help topic for the list option if you only know you are looking for a certain option you can also do h options txt to open the help page which describes all option handling and then you can search using regular expressions e g width certain options have their own namespace e g h cpo a h cpo a h cpo b and so on normal mode commands are just that use h gt to go to the help page for the gt command regexp items always start with so h \ takes you to the help item for the quantifier in vim regexes if you need to know anything about regular expressions start reading at h pattern txt key combinations they usually start with a single letter indicating the mode for which they can be used e g h i ctrl x takes you to the family of ctrl x commands for insert mode which can be used to auto complete different things note that certain keys will always be written the same e g control will always be ctrl note for normal mode commands the n is left away e g h ctrl a in contrast h c ctrl r will describe what ctrl r does when entering commands in the command line and h v ctrl a talks about incrementing numbers in visual mode and h g ctrl a talks about the g command thus you have to press g then here the g stand for the normal command g which always expect a second key before doing something similar to the commands starting with z registers always start with quote so use h quote to find out about the special register vim script viml is available at h eval txt certain aspects of the language are available at h expr x where x is a single letter e g h expr will take you to the topic describing the not operator for viml also important see h function list to find a short description of all functions available mappings are talked about in the help page h map txt use h mapmode i to find out about the imap command also use map topic to find out about certain subtopics particular for mappings e g h map local for buffer local mappings or h map bar for how the is handled in mappings command definitions are talked about at h command so use h command bar to find out about the argument for custom commands window management commands always start with ctrl w so you find the corresponding help at h ctrl w e g h ctrl w p for switch to the previously accessed window you can also access h windows txt and read your way through if you are looking for window handling command ex commands always start with so h s covers the s command use ctrl d after typing a topic and let vim try to complete to all available topics use helpgrep to search in all help pages usually also includes help pages by installed plugins see h helpgrep for how to use it once you have searched for a topic all matches are available in the quickfix or location window which can be opened with copen or lopen there you can also use to further filter the matches h helphelp contains some information on how to use the help the user manual this describes help topics for beginners in a rather friendly way start at h usr toc txt to find the table of content as you might have guessed skimming over that help to find certain topics e g you will find an entry digraphs and entering special characters in chapter 24 so use h usr 24 txt to go to that particular help page highlighting groups always start with hl e g h hl warningmsg talks about the warningmsg highlighting group syntax highlighting is namespaced to syn topic e g h syn conceal talks about the conceal argument for the syn command quickfix commands usually start with c while location list commands usually start with l h bufwinleave talks about the bufwinleave autocmd also h autocommands events talks about all possible events startup arguments always start with so h f takes you to the help of the f command switch of vim compiled extra features always start with so h conceal talks about the conceal support error codes can be looked up directly in the help h e297 takes you exactly to the description of the error message sometimes however those error codes are not described but rather are listed at the vim command that usually causes this e g h he128 takes you directly to the function command documentation for included syntax files is usually available at h ft syntax e g h ft c syntax talks about the c syntax file and the options it provides sometimes additional sections for omni completion h ft php omni or filetype plugins h ft tex plugin are available also a link to the user documentation which describes certain commands more from a user perspective and less detailed will be mentioned at the top of help pages if they are available so h pattern txt mentions the user guide topics h 03 9 and h usr 27 getting help online if you have an issue you cant resolve or are in need of general guidance see the vim use mailing list another great resource is using irc the channel vim on freenode is huge and usually full of helpful people if you want to report a vim bug use the vim dev mailing list autocmds in practice you can trigger any event right now doautocmd bufread user events especially for plugins its useful to create your own user events vim function chibby a lot of stuff is happening here and at last doautocmd user chibbyexit endfunction now users of your plugin can execute anything when chibby finishes running vim autocmd user chibbyexit call chibbycleanup by the way if theres no catching autocmd doautocmd will output a pesky no matching autocommands message thats why many plugins use silent doautocmd instead but this has the disadvantage that you cant simply use echo foo in the autocmd you have to use unsilent echo foo instead thats why its better to check if there even is a receiving autocmd and not bothering emitting the event otherwise vim if exists user chibbyexit doautocmd user chibbyexit endif help h user nested autocmds by default autocmds do not nest if an autocmd executes a command which in turn would usually trigger another event it wont happen lets say every time you start vim you want to automatically open your vimrc vim autocmd vimenter edit myvimrc when you now start vim it will open your vimrc but the first thing youll notice is that there wont be any highlighting although usually there would be the problem is that edit in your non nested autocmd wont trigger the bufread event so the filetype never gets set to vim and vimruntime syntax vim vim never sourced see au bufread vim use this instead vim autocmd vimenter nested edit myvimrc help h autocmd nested clipboard required features clipboard and optionally xterm clipboard if you want to use the clipboard option on a unix system with a vim that doesnt have gui support help h clipboard h gui clipboard h gui selections also see bracketed paste or why do i have to set paste all the time clipboard usage windows macos windows comes with a clipboard and macos comes with a pasteboard both work like most users would expect them to work you copy selected text with ctrl c cmd c and paste them in another application with ctrl v cmd v note that copied text is actually transferred to the clipboard so you can close the application you copied from before pasting in another application without problems whenever this happens the clipboard register gets filled with the selection from vim use y and p to yank and paste from the clipboard respectively if you dont even want to specify the register all the time put this in your vimrc vim set clipboard unnamed usually all yank delete put operations fill the register now the register is used for the same operations therefore simply y and p will be enough let me repeat using the option above means that every yank paste even when only used in the same vim window will alter the clipboard decide for yourself if this is useful or not if youre even too lazy to type y you can send every visual selection to the clipboard by using these settings vim set clipboard unnamed autoselect set guioptions a help h clipboard unnamed h autoselect h go a clipboard usage linux bsd if your os uses x things work a bit different x implements the x window system protocol which happens to be at major version 11 since 1987 hence x is also often called x11 prior in x10 cut buffers were introduced that kind of worked like a clipboard as in copied text was actually held by x and it was accessible by all other applications this mechanism still exists in x but its use is deprecated now and most software doesnt use it anymore nowadays data is transferred between applications by the means of selections from the 3 selection atoms defined only 2 are used in practice primary and clipboard selections work roughly like this program a ctrl c program a assert ownership of clipboard program b ctrl v program b note that ownership of clipboard is hold by program a program b request data from program a program a respond to request and send data to program b program b receives data from program a and inserts it into the window selection when used how to paste how to access from vim primary selecting text middle click shift insert register clipboard selecting text and ctrl c ctrl v register note selections no not even the clipboard selection are never kept in the x server thus you lose the data copied with ctrl c when the application closes use p to paste the primary selection or y1g to yank the entire file to the clipboard selection if you happen to access one of the two registers all the time consider using vim set clipboard unnamed register or set clipboard unnamedplus register the is used to prepend to the default value h set this will make all yank delete put operations use either or instead of the unnamed register afterwards you can simply use y or p for accessing your chosen x selection help vim h clipboard unnamed h clipboard unnamedplus restore cursor position when opening file when you open a file the cursor will be positioned at line 1 column 1 fortunately the viminfo file remembers marks the mark contains the position in the buffer where you left off vim autocmd bufreadpost \ if line \ 1 line \ line \ execute normal g \ \ endif read if the mark contains a line number greater than line 1 but not greater than the last line in the file jump to it h viminfo h quote h g temporary files backup files before saving a file vim creates a backup file if writing to disk was successful the backup file will be deleted with set backup the backup will persist this means the backup file will always have the same content as the original file before the most recent save its up to you to decide whether this is useful or not you can disable backups entirely with set nobackup nowritebackup but you shouldnt need to nowadays writebackup is a security feature that makes sure that you dont lose the original file in case saving it should ever fail no matter whether you keep the backup file afterwards or not if you frequently use vim to edit huge files and you probably shouldnt you can exclude those from backups with backupskip vim knows different ways to create a backup copying and renaming copying a full copy of the original file is created and used as backup the original file gets emptied and then filled with the content of the vim buffer renaming the original file is renamed to the backup file the content of the vim buffer gets written to a new file with the name of the original file see h backupcopy for all the nitty gritty details demo vim set backup backupskip backupdir backupext backup e tmp foo ifoo esc w original file gets created no need for backup file obar esc w backup file is created original file gets updated diff diff u tmp foo backup tmp foo tmp foo backup 2017 04 22 15 05 13 000000000 0200 tmp foo 2017 04 22 15 05 25 000000000 0200 1 1 2 foo bar h backup h write fail swap files when editing a file unsaved changes get written to a swap file get the name of the current swap file with swapname disable them with set noswapfile a swap file gets updated either all 200 characters or when nothing was typed for 4 seconds they get deleted when you stop editing the file you can change these numbers with h updatecount and h updatetime if vim gets killed e g power outage you lose all changes since the last time the file was written to disk but the swap file wont be deleted now if you edit the file again vim will offer the chance to recover the file from the swap file when two people try to edit the same file the second person will get a notice that the swap file already exists it prevents people from trying to save different versions of a file if you dont want that behaviour see h directory h swap file h usr 11 undo files the undo tree is kept in memory and will be lost when vim quits if you want it to persist set undofile this will save the undo file for foo c in foo c un h undofile h undo persistence viminfo files when backup swap and undo files are all about text state viminfo files are used for saving everything else that would otherwise be lost when quitting vim the viminfo file keeps histories command line search input registers marks buffer list global variables etc by default the viminfo is written to viminfo h viminfo h viminfo example configuration for temporary files put all temporary files in their own directory under vim files vim create directory if needed if isdirectory home vim files exists mkdir call mkdir home vim files endif backup files set backup set backupdir home vim files backup set backupext vimbackup set backupskip swap files set directory home vim files swap set updatecount 100 undo files set undofile set undodir home vim files undo viminfo files set viminfo 100 n home vim files info viminfo editing remote files vim comes with the netrw plugin that enables editing remote files actually it transfers the remote file to a local temporary file via scp opens a buffer using that file and writes the changes back to the remote file on saving this is extremely useful if you want to use your local configuration opposed to sshing into a server and use whatever the admins want you to use e scp bram awesome site com vimrc if you have a ssh config set up already this gets used automatically host awesome hostname awesome site com port 1234 user bram assuming the above content in ssh config this works just as well e scp awesome vimrc similar can be done with a netrc see h netrw netrc make sure to read h netrw ssh hack and h g netrw ssh cmd another possibility is using sshfs which uses fuse to mount a remote filesystem into your local filesystem managing plugins pathogen was the first popular tool for managing plugins actually it just adjusts the runtimepath h rtp to include all the things put under a certain directory you have to clone the repositories of the plugins there yourself real plugin managers expose commands that help you to install and update plugins from within vim list of plugin managers block insert this is a technique to insert the same text on multiple consecutive lines at the same time see this demo switch to visual block mode with c v afterwards go down for a few lines hit i or a and start entering your text it might be a bit confusing at first but text is always entered for the current line and only after finishing the current insertion the same text will be applied to all other lines of the prior visual selection so a simple example is c v 3jitext esc if you have lines of different length and want to append the same text right after the end of each line do this c v 3j atext esc sometime you need to place the cursor somewhere after the end of the current line you cant do that by default but you can set the virtualedit option vim set virtualedit all afterwards 10l or 90 work even after the end of the line see h blockwise examples for more info it might seem complicated at first but quickly becomes second nature if you want to get real fancy have a look at multiple cursors running external programs and using filters disclaimer vim is single threaded so running an external program in the foreground will block everything else sure you can use one of vims programming interfaces e g lua and use its thread support but during that time the vim process is blocked nevertheless neovim fixed that by adding a proper job api apparently bram is thinking about adding job control to vim as well if you have a very recent version see helpgrep startjob use to start a job if you want to list the files in the current working directory use ls use for piping in the shell as usual e g ls 1 sort tail n5 without a range the output of will be shown in a scrollable window on the other hand if a range is given these lines will be filtered this means they will be piped to the stdin of the filter program and after processing be replaced by the stdout of the filter e g for prepending numbers to the next 5 lines use this 4 nl ba w1 s since manually adding the range is quite burdensome vim also provides some helpers for convenience as always with ranges you can also select lines in visual mode and then hit theres also an operator that takes a motion e g ip sort will sort the lines of the current paragraph a good use case for filtering is the go programming language the indentation is pretty opinionated it even comes with a filter called gofmt for indenting go source code properly so plugins for go often provide helper commands called fmt that basically do gofmt so they indent all lines in the file people often use r prog to put the output of prog below the current line which is fine for scripts but when doing it on the fly i find it easier to use ls instead which replaces the current line h filter h read cscope cscope does more things than ctags but only supports c and c and java to some extent whereas a tags file only knows where a symbol was defined a cscope database knows much more about your data where is this symbol defined where is this symbol used what is this global symbols definition where did this variable get its value where is this function in the source files what functions call this function what functions are called by this function where does the message out of space come from where is this source file in the directory structure what files include this header file 1 build the database do this in the root of your project sh cscope bqr this will create 3 files cscope in po out in the current working directory think of them as your database unfortunately cscope only analyzes c h y l files by default if you want to use cscope for a java project instead do this sh find name java cscope files cscope bq 2 add the database open a connection to your freshly built database vim cs add cscope out verify that the connection was made vim cs show yes you can add multiple connections 3 query the database vim cs find kind query e g cs find d foo will list all functions that are called by foo kind explanation s symbol find all references to the token g global find global definition s of the token c calls find all calls to the function t text find all instances of the text e egrep egrep search for the word f file open the filename i includes find files that include the filename d depends find functions called by this function i suggest some convenience mappings e g vim nnoremap buffer leader cs cscope find s c r expand cword cr cr nnoremap buffer leader cg cscope find g c r expand cword cr cr nnoremap buffer leader cc cscope find c c r expand cword cr cr nnoremap buffer leader ct cscope find t c r expand cword cr cr nnoremap buffer leader ce cscope find e c r expand cword cr cr nnoremap buffer leader cf cscope find f c r expand cfile cr cr nnoremap buffer leader ci cscope find i c r expand cfile cr cr nnoremap buffer leader cd cscope find d c r expand cword cr cr so when tag or c jumps to a definition from the tags file cstag does the same but also takes connected cscope databases into account the option cscopetag makes tag act like cstag automatically this is very convenient if you already have tag related mappings help h cscope matchit since vim is written in c a lot of features assume c like syntax by default if your cursor is on or endif you can use to jump to the corresponding or ifdef respectively vim comes bundled with a plugin called matchit vim which is not enabled by default it makes also cycle through html tags if else endif constructs in viml etc and introduces a few new commands installation for vim 8 vim vimrc packadd matchit installation for vim 7 and older vim vimrc runtime macros matchit vim since the documentation of matchit is pretty extensive i suggest also doing the following once vim mkdir p vim doc cp vimruntime macros matchit txt vim doc helptags vim doc small intro the plugin is ready to use now see h matchit intro for the supported commands and h matchit languages for the supported languages that said its easy to define your own matching pairs vim autocmd filetype python let b match words \ if\ \ elif\ \ else\ afterwards you can cycle through these 3 statements in any python file by using forward or g backward help h matchit install h matchit h b match words true colors using true colors in a terminal emulator means being able to use 24 bits for rgb colors that makes 16777216 2 24 colors instead of the usual 256 as explained here colorschemes can actually be two colorschemes by having definitions for terminals xterm and for guis gvim this made sense before terminal emulators learned about true colors after set termguicolors vim starts emitting escape sequences only understood by a terminal emulator that supports true colors when your colors look weird chances are your terminal emulator doesnt support true colors or your colorcheme has no gui colors defined many people use the terminal multiplexer tmux which basically sits in between the terminal emulator and vim to make tmux forward the true color escape sequences emitted by vim you have to put the following in the users tmux conf set option g default terminal tmux 256color set option ga terminal overrides xterm 256color tc the first line should be the same for most people and denotes the term to be used within tmux the second line adds the tmux specific tc true color capability to the other terminfo entries of xterm 256color obviously this assumes that the user is using term xterm 256color outside of tmux so here is the checklist for enabling true colors read h termguicolors put set termguicolors in your vimrc make sure your colorscheme has color definitions for guis it should contain lines with guifg and guibg make sure your terminal emulator of choice supports true colors using tmux configure it to add the tc capability a popular reference for colors in the terminal https gist github com xvilka 8346728 tips saner behavior of n and n the direction of n and n depends on whether or was used for searching forward or backward respectively this is pretty confusing to me if you want n to always search forward and n backward use this vim nnoremap expr n nn v searchforward nnoremap expr n nn v searchforward saner command line history if youre anything like me youre used to going to next and previous items via c n and c p respectively by default this also works in the command line and recalls older or more recent command lines from history so far so good but up and down are even smarter they recall the command line whose beginning matches the current command line e g echo up may change to echo vim rocks of course i dont want you to reach to the arrow keys just map it instead vim cnoremap c n down cnoremap c p up i depend on this behaviour several times a day saner ctrl l by default c l clears and redraws the screen like redraw the following mapping does the same plus de highlighting the matches found via etc plus fixing syntax highlighting sometimes vim loses highlighting due to complex highlighting rules plus force updating the syntax highlighting in diff mode vim nnoremap leader l nohlsearch cr diffupdate cr syntax sync fromstart cr c l disable audible and visual bells vim set noerrorbells set novisualbell set t vb see vim wiki disable beeping quickly move current line sometimes i need a quick way to move the current line above or below vim nnoremap e c u execute move 1 v count1 cr nnoremap e c u execute move v count1 cr these mappings also take a count so 2 e moves the current line 2 lines below quickly add empty lines vim nnoremap space c u put repeat nr2char 10 v count1 cr nnoremap space c u put repeat nr2char 10 v count1 cr now 5 space inserts 5 blank lines above the current line quickly edit your macros this is a real gem the mapping takes a register or by default and opens it in the cmdline window hit cr when youre done editing for setting the register i often use this to correct typos i did while recording a macro vim nnoremap leader m c u c r c r let v register string getreg v register cr c f left use it like this leader m or q leader m notice the use of c r c r to make sure that the c r is inserted literally see h c r r quickly jump to header or source file this technique can probably be applied to many filetypes it sets file marks see h marks when leaving a source or header file so you can quickly jump back to the last accessed one by using c or h see h a vim autocmd bufleave c cpp mark c autocmd bufleave h mark h note the info is saved in the viminfo file so make sure that set viminfo includes h viminfo quickly change font size in gui i think this was taken from tpopes config vim command bigger let guifont substitute guifont \d\ \ submatch 0 1 command smaller let guifont substitute guifont \d\ \ submatch 0 1 change cursor style dependent on mode i like to use a block cursor in normal mode i beam cursor in insert mode and underline cursor in replace mode vim if empty tmux let t si \ esc 50 cursorshape 1\x7 let t ei \ esc 50 cursorshape 0\x7 let t sr \ esc 50 cursorshape 2\x7 else let t si \ esc ptmux \ esc \ esc 50 cursorshape 1\x7\ esc \ let t ei \ esc ptmux \ esc \ esc 50 cursorshape 0\x7\ esc \ let t sr \ esc ptmux \ esc \ esc 50 cursorshape 2\x7\ esc \ endif this simply tells vim to print a certain sequence of characters escape sequence when entering leaving insert mode the underlying terminal or programs like tmux that sit between vim and the terminal will process and evaluate it theres one drawback though there are many terminal emulator implementations and not all use the same sequences for doing the same things the sequences used above might not work with your implementation your implementation might not even support different cursor styles check the documentation the example above works with iterm2 dont lose selection when shifting sidewards if you select one or more lines you can use and for shifting them sidewards unfortunately you immediately lose the selection afterwards you can use gv to reselect the last selection see h gv thus you can work around it like this vim xnoremap gv xnoremap gv now you can use on your visual selection without any problems note the same can be achieved using which repeats the last change reload a file on saving using autocmds you can do anything on saving a file e g sourcing it in case of a dotfile or running a linter to check for syntactical errors in your source code vim autocmd bufwritepost myvimrc source myvimrc autocmd bufwritepost xdefaults call system xrdb xdefaults smarter cursorline i love the cursorline but i only want to use it in the current window and not when being in insert mode vim autocmd insertleave winenter set cursorline autocmd insertenter winleave set nocursorline faster keyword completion the keyword completion c n c p tries completing whatever is listed in the complete option by default this also includes tags which can be annoying and scanning all included files which can be very slow if you can live without these things disable them vim set complete i disable scanning included files set complete t disable searching tags cosmetic changes to colorschemes always use a dark gray statusline no matter what colorscheme is chosen vim autocmd colorscheme highlight statusline ctermbg darkgray cterm none guibg darkgray gui none this triggers every time you use colorscheme if you want it to trigger only for a certain colorscheme vim autocmd colorscheme desert highlight statusline ctermbg darkgray cterm none guibg darkgray gui none this triggers only for colorscheme desert commands useful commands that are good to know use h command name to learn more about them e g h global global and vglobal execute a command on all matching lines e g global regexp print will use print on all lines that contain regexp fun fact you probably all know good old grep the filter program written by ken thompson what does it do it prints all lines matching a certain regular expression now guess the short form of global regexp print thats right its g re p ken thompson was inspired by vis global when he wrote grep despite its name global only acts on all lines by default but it also takes a range assume you want use delete on all lines from the current line to the next blank line matched by the regular expression that contain foo vim g foo d for executing commands on all lines that do not match a given pattern use global or its alias vglobal think inverse instead normal and execute these commands are commonly used in vim scripts with normal you can do normal mode mappings from the command line e g normal 4j will make the cursor go down 4 lines without using any custom mapping for j due to the mind that normal also takes a range so norm iabc would prepend abc to every line with execute you can mix commands with expressions assume you edit a c source file and want to switch to its header file vim execute edit fnamemodify expand r h both commands are often used together assume you want to make the cursor go down n lines vim let n 4 execute normal n j redir and execute many commands print messages and redir allows to redirect that output you can redirect to files registers or variables vim redir var reg redir end echo var for fun lets also put it onto the current buffer put var in vim 8 there is an even shorter way vim put execute reg help h redir h execute debugging general tips if you encounter a strange behaviour try reproducing it like this vim u none n this will start vim without vimrc thus default settings and in nocompatible mode which makes it use vim defaults instead of vi defaults see h noplugin for other combinations of what to load at start if you can still reproduce it now its most likely a bug in vim itself report it to the vim dev mailing list most of the time the issue wont be resolved at this time and youll have to further investigate plugins often introduce new changed faulty behaviour e g if it happens on saving check verb au bufwritepost to get a list of potential culprits if youre using a plugin manager comment them out until you find the culprit issue is still not resolved if its not a plugin it must be your other settings so maybe your options or autocmds etc time to use binary search repeatedly split the search space in two until you find the culprit line due to the nature of binary division it wont take many steps in practice it works like this put the finish command in the middle of your vimrc vim will skip everything after it if it still happens the problem is in the active upper half move the finish to the middle of that half otherwise the issue is in the inactive lower half move the finish to the middle of that half and so on verbosity another useful way for observing what vim is currently doing is increasing the verbosity level currently vim supports 9 different levels see h verbose for the full list vim e tmp foo set verbose 2 w set verbose 0 this would show all the files that get sourced e g the undo file or various plugins that act on saving if you only want increase verbosity for a single command theres also verbose which simply gets put in front of any other command it takes the verbosity level as count and defaults to 1 vim verb set verbose verbose 1 10verb set verbose verbose 10 its very often used with its default verbosity level 1 to show where an option was set last vim verb set ai last set from vim vimrc naturally the higher the verbosity level the more overwhelming the output but fear no more you can simply redirect the output to a file vim set verbosefile tmp foo 15verbose echo foo vsplit tmp foo you can also enable verbosity at starting time with the v option it defaults to verbosity level 10 e g vim v5 profiling startup time vim startup feels slow time to crunch some numbers vim startuptime tmp startup log q vim tmp startup log the first column is the most important as it shows the elapsed absolute time if there is a big jump in time between two lines the second line is either a very big file or a file with faulty viml code that is worth investigating profiling at runtime required feature profile vim provides a built in capability for profiling at runtime and is a great way to find slow code in your environment the profile command takes a bunch of sub commands for specifying what to profile if you want to profile everything do this profile start tmp profile log profile file profile func do something in vim quit vim vim keeps the profiling information in memory and only writes it out to the logfile on exit neovim has fixed this using profile dump have a look at tmp profile log all code that was executed during profiling will be shown every line how often it was executed and how much time it took most of the time that will be plugin code the user isnt familiar with but if youre investigating a certain issue jump to the bottom of the log here are two different sections functions sorted on total time and functions sorted on self time that are worth gold at a quick glance you can see if a certain function is taking too long debugging vim scripts if you ever used a command line debugger before debug will quickly feel familiar simply prepend debug to any other command and youll be put into debug mode that is the execution will stop at the first line about to be executed and that line will be displayed see h cont and below for the 6 available debugger commands and note that like in gdb and similar debuggers you can also use their short forms c q n s i and f apart from that those youre free to use any vim command e g echo myvar which gets executed in the context of the current position in the code you basically get a repl by simply using debug 1 it would be a pain if you had to single step through every single line so of course we can define breakpoints too breakpoints are called breakpoints because the execution stops when theyre hit thus you can simply skip code youre not interested in see h breakadd h breakdel and h breaklist for further details lets assume you want to know what code is run every time you save a file vim au bufwritepost signify bufwritepost call sy start breakadd func start w breakpoint in sy start line 1 entering debug mode type cont to continue function sy start line 1 if g signify locked s function sy start line 3 endif function sy start line 5 let sy path resolve expand p q breakdel as you can see using cr will repeat the previous debugger command s in this case debug can be used in combination with the verbose option debugging syntax files syntax files are often the cause for slowdowns due to wrong and or complex regular expressions if the profile feature is compiled in vim provides the super useful syntime command vim syntime on hit c l a few times to redraw the window which causes the syntax rules to get applied again syntime off syntime report the output contains important metrics e g you can see which regexp takes too long and should be optimized or which regexps are used all the time but never even match see h syntime miscellaneous additional resources resource description seven habits of effective text editing by bram moolenaar the author of vim seven habits of effective text editing 2 0 pdf see above ibm developerworks scripting the vim editor five part series on vim scripting learn vimscript the hard way develop a vim plugin from scratch practical vim 2nd edition hands down the best book about vim vimcasts org vim screencasts wincents screencasts on youtube vim screencasts why oh why do those nutheads use vi common misconceptions explained your problem with vim is that you dont grok vi concise informative and correct a real gem vim distributions vim distributions are bundles of custom settings and plugins for vim more advanced users know how to configure their editor anyway so distributions are mostly targeted at beginners if you think about that its quite paradoxical though making it easier by adding even more things to learn about i know that many people dont want to spend hours and hours on customizing an editor and actually you never stop customizing your vimrc when you finally got hooked but eventually you only get efficient in vim when you take the time to learn it properly repeat after me a programmer should know their tools anyway if you know what youre doing you might draw some inspiration from looking at a few distributions cream janus spacevim spf13 standard plugins surprising to many people vim comes with a handful of plugins on its own that all get loaded by default check scriptnames after starting vim to see all sourced files most of them will never get used so disable them as you see fit they will still be shown as sourced but only the first lines actually get read before vim bails out no further code mappings commands logic will be processed plugin disable it using help 2html let g loaded 2html plugin 1 h 2html getscript let g loaded getscriptplugin 1 h pi getscript gzip let g loaded gzip 1 h pi gzip logipat let g loaded logipat 1 h pi logipat matchparen let g loaded matchparen 1 h pi paren netrw let g loaded netrwplugin 1 h pi netrw rrhelper let g loaded rrhelper 1 e vimruntime plugin rrhelper vim spellfile let g loaded spellfile plugin 1 h spellfile vim tar let g loaded tarplugin 1 h pi tar vimball let g loaded vimballplugin 1 h pi vimball zip let g loaded zipplugin 1 h pi zip map capslock to control capslock belongs to the most useless keys on your keyboard but its much easier to reach than the control key since it lies on your home row mapping capslock to control is a great way to prevent or at least reduce rsi if you program a lot attention when you get used to it you cant live without it anymore macos system preferences keyboard keyboard tab modifier keys change capslock to control linux to change the keys in x put this in your xmodmap remove lock caps lock keysym caps lock control l add control control l afterwards source it via xmodmap xmodmap an alternative would be using caps2esc or xcape windows see superuser com map caps lock to control in windows 8 1 easter eggs command message ni do you demand a shrubbery h sm note use of the short form is rated pg h 42 what is the meaning of life the universe and everything douglas adams the only person who knew what this question really was about is now dead unfortunately so now you might wonder what the meaning of death is h usergettingbored when the user presses the same key 42 times just kidding h bar ceci nest pas une pipe h holy grail you found it arthur h map modes nunmap can also be used outside of a monastery help e478 dont panic glitch when used in a help buffer buftype help this works like h help txt instead smile try it out yourself added in 7 4 1005 why hjkl for navigation when bill joy created vi a predecessor of vim he did it on a adm 3a which had no extra cursor buttons but used you might already guessed it hjkl instead keyboard layout click this also shows why is used to denote the home directory on unix systems common problems editing small files is slow there are two things which can have a huge impact on performance complex regular expressions particular the ruby syntax file caused people to have slowdowns in the past also see debugging syntax files screen redraws some features force all lines to redraw typical culprit why solution set cursorline causes all lines to redraw set nocursorline set cursorcolumn causes all lines to redraw set nocursorcolumn set relativenumber causes all lines to redraw set norelativenumber set foldmethod syntax if the syntax file is slow already this makes it even worse set foldmethod manual set foldmethod marker or fastfold set synmaxcol 3000 due to internal representation vim has problems with long lines in general highlights columns till column 3000 set synmaxcol 200 matchparen vim loaded by default uses regular expressions to find the accompanying parenthesis disable plugin h matchparen note you only need to do this if you experience actual performance drawbacks in most cases using the things mentioned above is absolutely fine editing huge files is slow the biggest issue with big files is that vim reads the whole file at once this is done due to how buffers are represented internally discussion on vim dev if you only want to read tail hugefile vim is a good workaround if you can live without syntax settings and plugins for the moment vim u none n this should make navigation quite a lot faster especially since no expensive regular expressions for syntax highlighting are used you should also tell vim not to use swapfiles and viminfo files to avoid long delays on writing vim n u none i none n putting it in a nutshell try to avoid using vim when intending to write really huge files \ bracketed paste or why do i have to set paste all the time bracketed paste mode allows terminal emulators to distinguish between typed text and pasted text did you ever tried pasting code into vim and afterwards everything seemed messed up this only happens if you paste via cmd v shift insert middle click etc because then youre just throwing text at the terminal emulator vim doesnt know that you just pasted the text it thinks youre an extremely fast typist accordingly it tries to indent the lines and fails obviously this is not an issue if you paste using vims registers e g p because then vim knows that youre actually pasting to workaround this you have to set paste so it gets pasted as is see h paste and h pastetoggle if youre fed up with toggling paste all the time have a look at this fine plugin that does it for you bracketed paste additional read from the same author as the plugin here neovim neovim tries to make all of this much more seamless and sets bracketed paste mode automatically if the terminal emulator supports it delays when using escape key in terminal if you live in the command line you probably use a so called terminal emulator like xterm gnome terminal iterm2 etc opposed to a real terminal like their ancestors terminal emulators use escape sequences or control sequences to control things like moving the cursor changing text colors etc theyre simply strings of ascii characters starting with an escape character displayed in caret notation as when such a string arrives the terminal emulator looks up the accompanying action in the terminfo database to make the problem clearer ill explain mapping timeouts first they always happen when theres ambiguity between mappings vim nnoremap a echo foo cr nnoremap ab echo bar cr both mappings work as expected but when typing a there will be a delay of 1 second because vim waits whether the user keys in another b or not escape sequences pose the same problem esc is used a lot for returning to normal mode or quitting an action cursor keys are encoded using escape sequences vim expects alt also called meta key to send a proper 8 bit encoding with the high bit set but many terminal emulators dont support it or dont enable it by default and send an escape sequence instead you can test the above like this vim u none n and type i c v left and youll see a sequence inserted that starts with which denotes the escape character putting it in a nutshell vim has a hard time distinguishing between a typed esc character and a proper escape sequence by default vim uses set timeout timeoutlen 1000 so it delays on ambiguity of mappings and key codes by 1 second this is a sane value for mappings but you can define the key code timeout on its own which is the most common workaround for this entire issue vim set timeout for mappings set timeoutlen 1000 default value set ttimeout for key codes set ttimeoutlen 10 unnoticeable small value under h ttimeout you find a small table showing the relationship between these options if youre using tmux between vim and your terminal emulator also put this in your tmux conf tmux set sg escape time 0 function search undo a search pattern in a command substitute changes the last used search pattern its saved in the register print it with echo a simple text change can be redone with its saved in the register print it with echo both things are not the case if you do them from a function though thus you cant easily highlight words from a function or redo the text changes made by it help h function search undo technical quirks newline used for nul nul characters \0 in a file are stored as newline \n in memory and displayed in a buffer as see man 7 ascii and h nl used for nul for more information