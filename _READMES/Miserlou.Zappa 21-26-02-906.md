zappa serverless python start doctoc generated toc please keep comment here to allow auto update dont edit this section instead re run doctoc to update about installation and configuration running the initial setup settings basic usage initial deployments updates rollback scheduling advanced scheduling undeploy package how zappa makes packages template status tailing logs remote function invocation django management commands ssl certification deploying to a domain with aws certificate manager deploying to a domain with a lets encrypt certificate dns auth deploying to a domain with a lets encrypt certificate http auth deploying to a domain with your own ssl certs executing in response to aws events asynchronous task execution task sources direct invocation remote invocations restrictions running tasks in a vpc responses advanced settings yaml settings advanced usage keeping the server warm serving static files binary uploads enabling cors large projects enabling bash completion enabling secure endpoints on api gateway api key iam policy api gateway authorizers cognito user pool authorizer setting environment variables local environment variables remote aws environment variables remote environment variables remote environment variables via an s3 file api gateway context variables catching unhandled exceptions using custom aws iam roles and policies for deployment using custom aws iam roles and policies for execution aws x ray globally available server less architectures raising aws service limits using zappa with docker dead letter queues unique package id zappa guides zappa in the press sites using zappa related projects hacks contributing using a local repo patrons merch support development training consulting end doctoc generated toc please keep comment here to allow auto update about in a hurry click to see now slightly out dated slides from serverless sf zappa makes it super easy to build and deploy server less event driven python applications including but not limited to wsgi web apps on aws lambda api gateway think of it as serverless web hosting for your python apps that means infinite scaling zero downtime zero maintenance and at a fraction of the cost of your current deployments if youve got a python web app including django and flask apps its as easy as pip install zappa zappa init zappa deploy and now youre server less wow what do you mean serverless okay so there still is a server but it only has a 40 millisecond life cycle serverless in this case means without any permanent infrastructure with a traditional http server the server is online 24 7 processing requests one by one as they come in if the queue of incoming requests grows too large some requests will time out with zappa each request is given its own virtual http server by amazon api gateway aws handles the horizontal scaling automatically so no requests ever time out each request then calls your application from a memory cache in aws lambda and returns the response via pythons wsgi interface after your app returns the server dies better still with zappa you only pay for the milliseconds of server time that you use so its many orders of magnitude cheaper than vps paas hosts like linode or heroku and in most cases its completely free plus theres no need to worry about load balancing or keeping servers online ever again its great for deploying serverless microservices with frameworks like flask and bottle and for hosting larger web apps and cmses with django or you can use any wsgi compatible app you like you probably dont need to change your existing applications to use it and youre not locked into using it zappa also lets you build hybrid event driven applications that can scale to trillions of events a year with no additional effort on your part you also get free ssl certificates global app deployment api access management automatic security policy generation precompiled c extensions auto keep warms oversized lambda packages and many other exclusive features and finally zappa is super easy to use you can deploy your application with a single command out of the box awesome installation and configuration before you begin make sure you are running python 2 7 or python 3 6 and you have a valid aws account and your aws credentials file is properly installed zappa can easily be installed through pip like so pip install zappa please note that zappa must be installed into your projects virtual environment the virtual environment name should not be the same as the zappa project name as this may cause errors if you use pyenv and love to manage virtualenvs with pyenv virtualenv you just have to call pyenv local your venv name and its ready conda users should comment here next youll need to define your local and server side settings running the initial setup settings zappa can automatically set up your deployment settings for you with the init command zappa init this will automatically detect your application type flask django pyramid users see here and help you define your deployment configuration settings once you finish initialization youll have a file named zappa settings json in your project directory defining your basic deployment settings it will probably look something like this for most wsgi apps javascript the name of your stage dev the name of your s3 bucket s3 bucket lmbda the modular python path to your wsgi application function in flask and bottle this is your app object flask your module py app flask bottle your module py app bottle default app app function your module app or for django javascript dev the name of your stage s3 bucket lmbda the name of your s3 bucket django settings your project settings the python path to your django settings psst if youre deploying a django application with zappa for the first time you might want to read edgar romans django zappa guide you can define as many stages as your like we recommend having dev staging and production now youre ready to deploy basic usage initial deployments once your settings are configured you can package and deploy your application to a stage called production with a single command zappa deploy production deploying your application is now live at https 7k6anj0k99 execute api us east 1 amazonaws com production and now your app is live how cool is that to explain whats going on when you call deploy zappa will automatically package up your application and local virtual environment into a lambda compatible archive replace any dependencies with versions precompiled for lambda set up the function handler and necessary wsgi middleware upload the archive to s3 create and manage the necessary amazon iam policies and roles register it as a new lambda function create a new api gateway resource create wsgi compatible routes for it link it to the new lambda function and finally delete the archive from your s3 bucket handy be aware that the default iam role and policy created for executing lambda applies a liberal set of permissions these are most likely not appropriate for production deployment of important applications see the section using custom aws iam roles and policies for execution for more detail updates if your application has already been deployed and you only need to upload new python code but not touch the underlying routes you can simply zappa update production updating your application is now live at https 7k6anj0k99 execute api us east 1 amazonaws com production this creates a new archive uploads it to s3 and updates the lambda function to use the new code but doesnt touch the api gateway routes rollback you can also rollback the deployed code to a previous version by supplying the number of revisions to return to for instance to rollback to the version deployed 3 versions ago zappa rollback production n 3 scheduling zappa can be used to easily schedule functions to occur on regular intervals this provides a much nicer maintenance free alternative to celery these functions will be packaged and deployed along with your app function and called from the handler automatically just list your functions and the expression to schedule them using cron or rate syntax in your zappa settings json file javascript production events function your module your function the function to execute expression rate 1 minute when to execute it in cron or rate format and then zappa schedule production and now your function will execute every minute if you want to cancel these you can simply use the unschedule command zappa unschedule production and now your scheduled event rules are deleted see the example for more details advanced scheduling sometimes a function needs multiple expressions to describe its schedule to set multiple expressions simply list your functions and the list of expressions to schedule them using cron or rate syntax in your zappa settings json file javascript production events function your module your function the function to execute expressions cron 0 20 23 sun thu cron 0 0 8 mon fri when to execute it in cron or rate format this can be used to deal with issues arising from the utc timezone crossing midnight during business hours in your local timezone it should be noted that overlapping expressions will not throw a warning and should be checked for to prevent duplicate triggering of functions undeploy if you need to remove the api gateway and lambda function that you have previously published you can simply zappa undeploy production you will be asked for confirmation before it executes if you enabled cloudwatch logs for your api gateway service and you dont want to keep those logs you can specify the remove logs argument to purge the logs for your api gateway and your lambda function zappa undeploy production remove logs package if you want to build your application package without actually uploading and registering it as a lambda function you can use the package command zappa package production if you have a zip callback in your callbacks setting this will also be invoked javascript production the name of your stage callbacks zip my app zip callback after creating the package you can also specify the output filename of the package with o zappa package production o my awesome package zip how zappa makes packages zappa will automatically package your active virtual environment into a package which runs smoothly on aws lambda during this process it will replace any local dependancies with aws lambda compatible versions dependencies are included in this order lambda compatible manylinux wheels from a local cache lambda compatible manylinux wheels from pypi lambda specific versions from lambda package packages from the active virtual environment packages from the local project directory it also skips certain unnecessary files and ignores any py files if pyc files are available in addition zappa will also automatically set the correct execution permissions configure package settings and create a unique auditable package manifest file to further reduce the final package file size you can set slim handler to true to upload a small handler to lambdas and the rest of the package to s3 for more details see the merged pull request and the discussion in the original issue see also large projects use the exclude setting and provide a list of regex patterns to exclude from the archive by default zappa will exclude boto because its already available in the lambda execution environment template similarly to package if you only want the api gateway cloudformation template for use the template command zappa template production l your lambda arn r your role arn note that you must supply your own lambda arn and role arns in this case as they may not have been created for you you can get the json output directly with json and specify the output file with output status if you need to see the status of your deployment and event schedules simply use the status command zappa status production tailing logs you can watch the logs of a deployment by calling the tail management command zappa tail production by default this will show all log items in addition to http and other events anything printed to stdout or stderr will be shown in the logs you can use the argument http to filter for http requests which will be in the apache common log format zappa tail production http similarly you can do the inverse and only show non http events and log messages zappa tail production non http if you dont like the default log colors you can turn them off with no color you can also limit the length of the tail with since which accepts a simple duration string zappa tail production since 4h 4 hours zappa tail production since 1m 1 minute zappa tail production since 1mm 1 month you can filter out the contents of the logs with filter like so zappa tail production http filter post only show post http requests note that this uses the cloudwatch logs filter syntax remote function invocation you can execute any function in your application directly at any time by using the invoke command for instance suppose you have a basic application in a file called my app py and you want to invoke a function in it called my function once your application is deployed you can invoke that function at any time by calling zappa invoke production my app my function any remote print statements made and the value the function returned will then be printed to your local console nifty you can also invoke interpretable python 2 7 or python 3 6 strings directly by using raw like so zappa invoke production print 1 2 3 raw django management commands as a convenience zappa can also invoke remote django manage py commands with the manage command for instance to perform the basic django status check zappa manage production showmigrations admin obviously this only works for django projects which have their settings properly defined for commands which have their own arguments you can also pass the command in as a string like so zappa manage production shell version commands which require direct user input such as createsuperuser should be replaced by commands which use zappa invoke env raw for more django integration take a look at the zappa django utils project please note that commands which take over 30 seconds to execute may time out preventing output from being returned but the command may continue to run see this related issue for a work around ssl certification zappa can be deployed to custom domain names and subdomains with custom ssl certificates lets encrypt certificates and aws certificate manager acm certificates currently the easiest of these to use are the aws certificate manager certificates as they are free self renewing and require the least amount of work once configured as described below all of these methods use the same command zappa certify when deploying from a ci cd system you can use zappa certify yes to skip the confirmation prompt deploying to a domain with aws certificate manager amazon provides their own free alternative to lets encrypt called aws certificate manager acm to use this service with zappa verify your domain in the aws certificate manager console in the console select the n virginia us east 1 region and request a certificate for your domain or subdomain sub yourdomain tld or request a wildcard domain yourdomain tld copy the entire arn of that certificate and place it in the zappa setting certificate arn set your desired domain in the domain setting call zappa certify to create and associate the api gateway distribution using that certificate deploying to a domain with a lets encrypt certificate dns auth if you want to use zappa on a domain with a free lets encrypt certificate using automatic route 53 based dns authentication you can follow this handy guide deploying to a domain with a lets encrypt certificate http auth if you want to use zappa on a domain with a free lets encrypt certificate using http authentication you can follow this guide however its now far easier to use route 53 based dns authentication which will allow you to use a lets encrypt certificate with a single zappa certify command deploying to a domain with your own ssl certs the first step is to create a custom domain and obtain your ssl cert key bundle ensure you have set the domain setting within your zappa settings json this will avoid problems with the base path mapping between the custom domain and the api invoke url which gets the stage name appended in the uri add the paths to your ssl cert key bundle to the certificate certificate key and certificate chain settings respectively in your zappa settings json set route53 enabled to false if you plan on using your own dns provider and not an aws route53 hosted zone deploy or update your app using zappa run zappa certify to upload your certificates and register the custom domain name with your api gateway executing in response to aws events similarly you can have your functions execute in response to events that happen in the aws ecosystem such as s3 uploads dynamodb entries kinesis streams and sns messages in your zappa settings json file define your event sources and the function you wish to execute for instance this will execute your module process upload function in response to new objects in your my bucket s3 bucket note that process upload function must accept event and context parameters javascript production events function your module process upload function event source arn arn aws s3 my bucket events s3 objectcreated supported event types http docs aws amazon com amazons3 latest dev notificationhowto html supported notification event types and then zappa schedule production and now your function will execute every time a new upload appears in your bucket to access the keys information in your application context youll want process upload function to look something like this python import boto3 s3 client boto3 client s3 def process upload function event context process a file upload get the uploaded files information bucket event records 0 s3 bucket name will be my bucket key event records 0 s3 object key will be the file path of whatever file was uploaded get the bytes from s3 s3 client download file bucket key tmp key download this file to writable tmp space file bytes open tmp key read similarly for a simple notification service event javascript events function your module your function event source arn arn aws sns your event topic arn events sns publish optionally you can add sns message filters javascript events function your module your function event source arn arn aws sns your event topic arn filters interests python aws zappa version 1 0 dynamodb and kinesis are slightly different as it is not event based but pulling from a stream javascript events function replication replicate records event source arn arn aws dynamodb us east 1 1234554 table yourtable stream 2016 05 11t00 00 00 000 starting position trim horizon supported values trim horizon latest batch size 50 max 1000 enabled true default is false for configuring lex bots intent triggered events javascript bot events function lexbot handlers book appointment handler event source arn arn aws lex us east 1 01234123123 intent testlexeventnames latest optional in future it will be used to configure the intent intent intentname name of the bot event configured invocation source dialogcodehook either fulfillmentcodehook or dialogcodehook events can also take keyword arguments javascript events function your module your recurring function the function to execute kwargs key val key2 val2 keyword arguments to pass these are available in the event expression rate 1 minute when to execute it in cron or rate format to get the keyword arguments you will need to look inside the event dictionary python def your recurring function event context my kwargs event get kwargs dict of kwargs given in zappa settings file you can find more example event sources here asynchronous task execution zappa also now offers the ability to seamlessly execute functions asynchronously in a completely separate aws lambda instance for example if you have a flask api for ordering a pie you can call your bake function seamlessly in a completely separate lambda instance by using the zappa async task decorator like so python from flask import flask from zappa async import task app flask name task def make pie this takes a long time ingredients get ingredients pie bake ingredients deliver pie app route api order pie def order pie this returns immediately make pie return your pie is being made and thats it your api response will return immediately while the make pie function executes in a completely different lambda instance when calls to task decorated functions or the zappa async run command occur outside of lambda such as your local dev environment the functions will execute immediately and locally the zappa async functionality only works when in the lambda environment or when specifying remote invocations task sources by default this feature uses direct aws lambda invocation you can instead use aws simple notification service as the task event source by using the task sns decorator like so python from zappa async import task sns task sns using sns also requires setting the following settings in your zappa settings javascript dev async source sns source of async tasks defaults to lambda async resources true create the sns topic to use defaults to true this will automatically create and subscribe to the sns topic the code will use when you call the zappa schedule command using sns will also return a message id in case you need to track your invocations direct invocation you can also use this functionality without a decorator by passing your function to zappa async run like so python from zappa async import run run your function args kwargs using lambda run your function args kwargs service sns using sns remote invocations by default zappa will use lambdas current function name and current aws region if you wish to invoke a lambda with a different function name region or invoke your lambda from outside of lambda you must specify the remote aws lambda function name and remote aws region arguments so that the application knows which function and region to use for example if some part of our pizza making application had to live on an ec2 instance but we wished to call the make pie function on its own lambda instance we would do it as follows python task remote aws lambda function name pizza pie prod remote aws region us east 1 def make pie this takes a long time ingredients get ingredients pie bake ingredients deliver pie if those task parameters were not used then ec2 would execute the function locally these sameremote aws lambda function nameandremote aws region arguments can be used on the zappa async run function as well restrictions the following restrictions to this feature apply functions must have a clean import path i e no closures lambdas or methods args and kwargs must be json serializable the json serialized arguments must be within the size limits for lambda 128k or sns 256k events all of this code is still backwards compatible with non lambda environments it simply executes in a blocking fashion and returns the result running tasks in a vpc if youre running zappa in a virtual private cloud vpc youll need to configure your subnets to allow your lambda to communicate with services inside your vpc as well as the public internet a minimal setup requires two subnets in subnet a create a nat create an internet gateway in the route table create a route pointing the internet gateway to 0 0 0 0 0 in subnet b place your lambda function in the route table create a route pointing the nat that belongs to subnet a to 0 0 0 0 0 you can place your lambda in multiple subnets that are configured the same way as subnet b for high availability some helpful resources are this tutorial this other tutorial and this aws doc page responses it is possible to capture the responses of asynchronous tasks zappa uses dynamodb as the backend for these to capture responses you must configure a async response table in zappa settings this is the dynamodb table name then when decorating with task pass capture response true async responses are assigned a response id this is returned as a property of the lambdaasyncresponse or snsasyncresponse object that is returned by the task decorator example python from zappa async import task get async response from flask import flask make response abort url for redirect request jsonify from time import sleep app flask name app route payload def payload delay request args get delay 60 x longrunner delay return redirect url for response response id x response id app route async response def response response id response get async response response id if response is none abort 404 if response status complete return jsonify response response sleep 5 return not yet ready redirecting 302 content type text plain charset utf 8 location url for response response id response id backoff 5 x redirect reason not yet ready task capture response true def longrunner delay sleep float delay return message it took seconds to generate this format delay advanced settings there are other settings that you can define in your local settings to change zappas behavior use these at your own risk javascript dev api key required false enable securing api gateway endpoints with x api key header default false api key your api key id optional use an existing api key the option api key required must be true to apply apigateway enabled true set to false if you dont want to create an api gateway resource default true apigateway description my funky application define a custom description for the api gateway console default none assume policy my assume policy json optional iam assume policy json file attach policy my attach policy json optional iam attach policy json file async source sns source of async tasks defaults to lambda async resources true create the sns topic and dynamodb table to use defaults to true async response table your dynamodb table name the dynamodb table name to use for captured async responses defaults to none cant capture async response table read capacity 1 dynamodb table read capacity defaults to 1 async response table write capacity 1 dynamodb table write capacity defaults to 1 aws endpoint urls aws service name endpoint url a dictionary of endpoint urls that emulate the appropriate service usually used for testing for instance with localstack aws environment variables your key your value a dictionary of environment variables that will be available to your deployed app via aws lambdas native environment variables see also environment variables and remote env default aws kms key arn your aws kms key arn your aws kms key arn aws region aws region name optional uses region set in profile or environment variables if not set here binary support true enable automatic mime type based response encoding through api gateway default true callbacks call custom functions during the local zappa deployment update process settings my app settings callback after loading the settings zip my app zip callback after creating the package post my app post callback after command has executed cache cluster enabled false use apigw cache cluster default false cache cluster size 0 5 apigw cache cluster size default 0 5 cache cluster ttl 300 apigw cache cluster time to live default 300 cache cluster encrypted false whether or now apigw cache cluster encrypts data default false certificate my cert crt ssl certificate file location used to manually certify a custom domain certificate key my key key ssl key file location used to manually certify a custom domain certificate chain my cert chain pem ssl certificate chain file location used to manually certify a custom domain certificate arn arn aws acm us east 1 1234512345 certificate aaaa bbb cccc dddd acm certificate arn needs to be in us east 1 region cloudwatch log level off enables configures a level of logging for the given staging available options off info error default off c cloudwatch data trace false logs all data about received events default false cloudwatch metrics enabled false additional metrics for the api gateway default false cognito for cognito event triggers user pool user pool id user pool id from aws cognito triggers source presignup signup triggersource from http docs aws amazon com cognito latest developerguide cognito user identity pools working with aws lambda triggers html cognito user pools lambda trigger syntax pre signup function my app pre signup function context header mappings http header name api gateway context variable a dictionary mapping http header names to api gateway context variables cors false enable cross origin resource sharing default false if true simulates the enable cors button on the api gateway console can also be a dictionary specifying lists of allowed headers allowed methods and string of allowed origin dead letter arn arn aws sns sqs my topic queue optional dead letter configuration for when lambda async invoke fails thrice debug true print zappa configuration errors tracebacks in the 500 default true delete local zip true delete the local zip archive after code updates default true delete s3 zip true delete the s3 zip archive default true django settings your project production settings the modular path to your django projects settings for django projects only domain yourapp yourdomain com required if youre using a domain base path your base path optional base path for api gateway custom domain base path mapping default none environment variables your key your value a dictionary of environment variables that will be available to your deployed app see also remote env and aws environment variables default events recurring events function your module your recurring function the function to execute expression rate 1 minute when to execute it in cron or rate format aws reactive events function your module your reactive function the function to execute event source arn arn aws s3 my bucket the arn of this event source events s3 objectcreated the specific event to execute in response to exception handler your module report exception function that will be invoked in case zappa sees an unhandled exception raised from your code exclude gz rar a list of regex patterns to exclude from the archive to exclude boto3 and botocore available in an older version on lambda add boto3 and botocore extends stage name duplicate and extend another stages settings for example dev asia could extend from dev common with a different s3 bucket value extra permissions attach any extra permissions to this policy default none effect allow action rekognition aws service arn resource iam authorization true optional use iam to require request signing default false note that enabling this will override the authorizer configuration include your special library to load at handler init load special libraries into pythonpath at handler init that certain modules cannot find on path authorizer function your module your auth function local function to run for token validation for more information about the function see below arn arn aws lambda region account id function function name existing lambda function to run for token validation result ttl 300 optional default 300 the time to live ttl period in seconds that specifies how long api gateway caches authorizer results currently the maximum ttl value is 3600 seconds token header authorization optional default authorization the name of a custom authorization header containing the token that clients submit as part of their requests validation expression bearer \\w optional a validation expression for the incoming token specify a regular expression keep warm true create cloudwatch events to keep the server warm default true to remove set to false and then unschedule keep warm expression rate 4 minutes how often to execute the keep warm in cron and rate format default 4 minutes lambda description your description however you want to describe your project for the aws console default zappa deployment lambda handler your custom handler the name of lambda handler default handler lambda handler lets encrypt key s3 your bucket account key lets encrypt account key path can either be an s3 path or a local file path log level debug set the zappa log level can be one of critical error warning info and debug default debug manage roles true have zappa automatically create and define iam execution roles and policies default true if false you must define your own iam role and role name setting memory size 512 lambda function memory in mb default 512 num retained versions null indicates the number of old versions to retain for the lambda if absent keeps all the versions of the function payload compression true whether or not to enable api gateway payload compression default true payload minimum compression size 0 the threshold size in bytes below which payload compression will not be applied default 0 prebuild script your module your function function to execute before uploading code profile name your profile name aws profile credentials to use default default removing this setting will use the aws access key id and aws secret access key environment variables instead project name myproject the name of the project as it appears on aws defaults to a slugified pwd remote env s3 my project config files filename json optional file in s3 bucket containing a flat json object which will be used to set custom environment variables role name mylambdarole name of zappa execution role default project name env zappaexecutionrole to use a different pre existing policy you must also set manage roles to false role arn arn aws iam 12345 role app zappalambdaexecutionrole arn of zappa execution role default to none to use a different pre existing policy you must also set manage roles to false this overrides role name use with temporary credentials via getfederationtoken route53 enabled true have zappa update your route53 hosted zones when certifying with a custom domain default true runtime python2 7 python runtime to use on lambda can be one of python2 7 or python3 6 defaults to whatever the current python being used is s3 bucket dev bucket zappa zip bucket slim handler false useful if project 50m set true to just upload a small handler to lambda and load actual project from s3 at runtime default false settings file projects myapp settings dev settings py server side settings file location tags attach additional tags to aws resources key value example key and value key2 value2 timeout seconds 30 maximum lifespan for the lambda function default 30 max 300 touch true get the production url upon initial deployment default true touch path the endpoint path to get when checking the initial deployment default use precompiled packages true if possible use c extension packages which have been pre compiled for aws lambda default true vpc config optional virtual private cloud vpc configuration for lambda function subnetids subnet 12345678 note not all availability zones support lambda securitygroupids sg 12345678 xray tracing false optional enable aws x ray tracing on your lambda function yaml settings if you prefer yaml over json you can also use a zappa settings yml like so yaml dev app function your module your app s3 bucket your code bucket events function your module your function event source arn arn aws s3 your event bucket events s3 objectcreated you can also supply a custom settings file at any time with the s argument ex zappa deploy dev s my custom settings yml similarly you can supply a zappa settings toml file toml dev app function your module your app s3 bucket your code bucket advanced usage keeping the server warm zappa will automatically set up a regularly occurring execution of your application in order to keep the lambda function warm this can be disabled via the keep warm setting serving static files binary uploads zappa is now able to serve and receive binary files as detected by their mime type however generally zappa is designed for running your application code not for serving static web assets if you plan on serving custom static assets in your web application css javascript images etc youll likely want to use a combination of aws s3 and aws cloudfront your web application framework will likely be able to handle this for you automatically for flask there is flask s3 and for django there is django storages similarly you may want to design your application so that static binary uploads go directly to s3 which then triggers an event response defined in your events setting thats thinking serverlessly enabling cors the simplest way to enable cors cross origin resource sharing for your zappa application is to set cors to true in your zappa settings file and update which is the equivalent of pushing the enable cors button in the aws api gateway console this is disabled by default but you may wish to enable it for apis which are accessed from other domains etc it may also conflict with binary support so you should set that to false in your settings you can also simply handle cors directly in your application your web framework will probably have an extension to do this such as django cors headers or flask cors using these will make your code more portable large projects aws currently limits lambda zip sizes to 50 megabytes if your project is larger than that set slim handler true in your zappa settings json in this case your fat application package will be replaced with a small handler only package the handler file then pulls the rest of the large project down from s3 at run time the initial load of the large project may add to startup overhead but the difference should be minimal on a warm lambda function note that this will also eat into the memory space of your application function enabling bash completion bash completion can be enabled by adding the following to your bashrc bash eval register python argcomplete zappa register python argcomplete is provided by the argcomplete python package if this package was installed in a virtualenv then the command must be run there alternatively you can execute activate global python argcomplete dest file the files contents should then be sourced in e g bashrc enabling secure endpoints on api gateway api key you can use the api key required setting to generate an api key to all the routes of your api gateway the process is as follows 1 deploy redeploy update wont work and write down the id for the key that has been created 2 go to aws console amazon api gateway and select api keys and find the key value for example key value select usage plans create a new usage plan and link the api key and the api that zappa has created for you 3 send a request where you pass the key value as a header called x api key to access the restricted endpoints for example with curl curl header x api key key value note that without the x api key header you will receive a 403 iam policy you can enable iam based v4 signing authorization on an api by setting the iam authorization setting to true your api will then require signed requests and access can be controlled via iam policy unsigned requests will receive a 403 response as will requesters who are not authorized to access the api enabling this will override the authorizer configuration see below api gateway authorizers if you deploy an api endpoint with zappa you can take advantage of api gateway authorizers to implement a token based authentication all you need to do is to provide a function to create the required output zappa takes care of the rest a good start for the function is the aws labs blueprint example if you are wondering for what you would use an authorizer here are some potential use cases call out to oauth provider decode a jwt token inline lookup in a self managed db for example dynamodb zappa can be configured to call a function inside your code to do the authorization or to call some other existing lambda function which lets you share the authorizer between multiple lambdas you control the behavior by specifying either the arn or function name values in the authorizer settings block for example to get the cognito identity add this to a zappa settings yaml yaml context header mappings user id authorizer user id which can now be accessed in flask like this python from flask import request route hello def hello world print request headers get user id cognito user pool authorizer you can also use aws cognito user pool authorizer by adding javascript authorizer type cognito user pools provider arns arn aws cognito idp region account id userpool user pool id setting environment variables local environment variables if you want to set local environment variables for a deployment stage you can simply set them in your zappa settings json javascript dev environment variables your key your value you can then access these inside your application with python import os your value os environ get your key if your project needs to be aware of the type of environment youre deployed to youll also be able to get servertype aws lambda framework zappa project your project name and stage dev production etc variables at any time remote aws environment variables if you want to use native aws lambda environment variables you can use the aws environment variables configuration setting these are useful as you can easily change them via the aws lambda console or cli at runtime they are also useful for storing sensitive credentials and to take advantage of kms encryption of environment variables during development you can add your zappa defined variables to your locally running app by for example using the below for django to manage py python if servertype in os environ and os environ servertype aws lambda import json import os json data open zappa settings json env vars json load json data dev environment variables for key val in env vars items os environ key val remote environment variables any environment variables that you have set outside of zappa via aws lambda console or cli will remain as they are when running update unless they are also in aws environment variables in which case the remote value will be overwritten by the one in the settings file if you are using kms encrypted aws environment variables you can set your kms key arn in the aws kms key arn setting make sure that the values you set are encrypted in such case note if you rely on these as well as environment variables and you have the same key names then those in environment variables will take precedence as they are injected in the lambda handler remote environment variables via an s3 file s3 remote environment variables were added to zappa before aws introduced native environment variables for lambda via the console and cli before going down this route check if above make more sense for your usecase if you want to use remote environment variables to configure your application which is especially useful for things like sensitive credentials you can create a file and place it in an s3 bucket to which your zappa application has access to to do this add the remote env key to zappa settings pointing to a file containing a flat json object so that each key value pair on the object will be set as an environment variable and value whenever a new lambda instance spins up for example to ensure your application has access to the database credentials without storing them in your version control you can add a file to s3 with the connection string and load it into the lambda environment using the remote env configuration setting super secret config json uploaded to my config bucket javascript db connection string super secret database zappa settings json javascript dev remote env s3 my config bucket super secret config json now in your application you can use python import os db string os environ get db connection string api gateway context variables if you want to map an api gateway context variable http docs aws amazon com apigateway latest developerguide api gateway mapping template reference html to an http header you can set up the mapping in zappa settings json javascript dev context header mappings http header name api gateway context variable for example if you want to expose the context identity cognitoidentityid variable as the http header cognitoidentityid and context stage as apistage you would have javascript dev context header mappings cognitoidentityid identity cognitoidentityid apistage stage catching unhandled exceptions by default if an unhandled exception happens in your code zappa will just print the stacktrace into a cloudwatch log if you wish to use an external reporting tool to take note of those exceptions you can use the exception handler configuration option zappa settings json javascript dev exception handler your module unhandled exceptions the function has to accept three arguments exception event and context your module py python def unhandled exceptions e event context send to raygun e event gather data you need and send return true prevent invocation retry you may still need a similar exception handler inside your application this is just a way to catch exception which happen at the zappa wsgi layer typically event based invocations misconfigured settings bad lambda packages and permissions issues by default aws lambda will attempt to retry an event based non api gateway e g cloudwatch invocation if an exception has been thrown however you can prevent this by returning true as in example above so zappa that will not re raise the uncaught exception thus preventing aws lambda from retrying the current invocation using custom aws iam roles and policies for deployment you can specify which local profile to use for deploying your zappa application by defining the profile name setting which will correspond to a profile in your aws credentials file using custom aws iam roles and policies for execution the default iam policy created by zappa for executing the lambda is very permissive it grants access to all actions for all resources for types cloudwatch s3 kinesis sns sqs dynamodb and route53 lambda invokefunction for all lambda resources put to all x ray resources and all network interface operations to all ec2 resources while this allows most lambdas to work correctly with no extra permissions it is generally not an acceptable set of permissions for most continuous integration pipelines or production deployments instead you will probably want to manually manage your iam policies to manually define the policy of your lambda execution role you must set manage roles to false and define either the role name or role arn in your zappa settings file javascript dev manage roles false disable zappa client managing roles role name mylambdarole name of your zappa execution role optional default project name env zappaexecutionrole role arn arn aws iam 12345 role app zappalambdaexecutionrole arn of your zappa execution role optional ongoing discussion about the minimum policy requirements necessary for a zappa deployment can be found here a more robust solution to managing these entitlements will likely be implemented soon to add permissions to the default zappa execution policy use the extra permissions setting javascript dev extra permissions attach any extra permissions to this policy effect allow action rekognition aws service arn resource aws x ray zappa can enable aws x ray support on your function with a configuration setting javascript dev xray tracing true this will enable it on the lambda function and allow you to instrument your code with x ray for example with flask python from aws xray sdk core import xray recorder from aws xray sdk ext flask middleware import xraymiddleware app flask name xray recorder configure service my app name xraymiddleware app xray recorder the official x ray documentation for python has more information on how to use this with your code globally available server less architectures click to see slides from serverlessconf london during the init process you will be given the option to deploy your application globally this will allow you to deploy your application to all available aws regions simultaneously in order to provide a consistent global speed increased redundancy data isolation and legal compliance you can also choose to deploy only to primary locations the aws regions with 1 in their names to learn more about these capabilities see these slides from serverlessconf london raising aws service limits out of the box aws sets a limit of 1000 concurrent executions for your functions if you start to breach these limits you may start to see errors like clienterror an error occurred limitexceededexception when calling the puttargets or something similar to avoid this you can file a service ticket with amazon to raise your limits up to the many tens of thousands of concurrent executions which you may need this is a fairly common practice with amazon designed to prevent you from accidentally creating extremely expensive bug reports so before raising your service limits make sure that you dont have any rogue scripts which could accidentally create tens of thousands of parallel executions that you dont want to pay for using zappa with docker if docker is part of your teams ci testing or deployments you may want to check out this handy guide on using zappa with docker dead letter queues if you want to utilise aws lambdas dead letter queue feature simply add the key dead letter arn with the value being the complete arn to the corresponding sns topic or sqs queue in your zappa settings json you must have already created the corresponding sns sqs topic queue and the lambda function execution role must have been provisioned with read publish sendmessage access to the dlq resource unique package id for monitoring of different deployments a unique uuid for each package is available in package info json in the root directory of your applications package you can use this information or a hash of this file for such things as tracking errors across different deployments monitoring status of deployments and other such things on services such as sentry and new relic the package will contain json build platform darwin build user frank build time 1509732511 uuid 9c2df9e6 30f4 4c0a ac4d 4ecb51831a74 zappa guides django zappa tutorial screencast using django zappa part 1 using django zappa part 2 vpcs building serverless microservices with zappa and flask zappa  hello world  japanese how to deploy zappa with cloudfront rds and vpc secure serverless file uploads with aws lambda s3 and zappa first steps with aws lambda zappa and python deploy a serverless wsgi app using zappa cloudfront rds and vpc aws deploy alexa ask skills with flask ask and zappa guide to using django with zappa zappa and lambci building a serverless image processing saas using zappa serverless slack slash commands with python and zappa bringing tokusatsu to aws using python flask zappa and contentful aws summit 2018 seoul zappa  serverless microservice your guide here zappa in the press zappa serves python minus the servers zappa lyfter serverlsa applikationer med python interview rich jones on zappa top 10 python libraries of 2016 sites using zappa zappa io a simple zappa homepage zappatista the official zappa blog mailchimp signup utility a microservice for adding people to a mailing list via api zappa slack inviter a tiny server less service for inviting new users to your slack channel serverless image host a thumbnailing service with flask zappa and pillow gigger the live music industrys search engine zappa bittorrent tracker an experimental server less bittorrent tracker work in progress jankyglance a server less yahoo pipes replacement lambdamailer a server less endpoint for processing a contact form voter registration microservice official backup to to the virginia department of elections portal freepoll online a simple and awesome say for groups to make decisions pasteofcode a zappa powered paste bin and many more including banks governments startups enterprises and schools are you using zappa let us know and well list your site here related projects lambda packages precompiled c extension packages for aws lambda used automatically by zappa mackenzie aws lambda infection toolkit nodb a simple server less pythonic object store based on s3 zappa cms a tiny server less cms for busy hackers work in progress zappa django utils utility commands to help django deployments flask ask a framework for building amazon alexa applications uses zappa for deployments zappa file widget a django plugin for supporting binary file uploads in django on zappa zops utilities for teams and continuous integrations using zappa cookiecutter mobile backend a cookiecutter django project with zappa and s3 uploads support zappa examples flask django image uploads and more zappa hug example example of a hug application using zappa zappa docker image a docker image for running zappa locally based on lambda docker zappa dashing monitor your aws environment health metrics with zappa and cloudwatch s3env manipulate a remote zappa environment variable key value json object file in an s3 bucket through the cli zappa resize image on fly resize images on the fly using flask zappa pillow and opencv python zappa ffmpeg run ffmpeg inside a lambda for serverless transformations gdrive lambda pass json data to a csv file for end users who use gdrive across the organization travis build repeat repeat travisci builds to avoid stale test results wunderskill alexa skill an alexa skill for adding to a wunderlist xrayvision utilities and wrappers for using aws x ray with zappa zappa sentry integration with zappa and sentry hacks zappa goes quite far beyond what lambda and api gateway were ever intended to handle as a result there are quite a few hacks in here that allow it to work some of those include but arent limited to using vtl to map body headers method params and query strings into json and then turning that into valid wsgi attaching response codes to response bodies base64 encoding the whole thing using that as a regex to route the response code decoding the body in vtl and mapping the response body to that packing and base58 encoding multiple cookies into a single cookie because we can only map one kind forcing the case permutations of set cookie in order to return multiple headers at the same time turning cookie setting 301 302 responses into 200 responses with html redirects because we have no way to set headers on redirects contributing this project is still young so there is still plenty to be done contributions are more than welcome please file tickets for discussion before submitting patches pull requests should target master and should leave zappa in a shippable state if merged if you are adding a non trivial amount of new code please include a functioning test in your pr for aws calls we use the placebo library which you can learn to use in their readme the test suite will be run by travis ci once you open a pull request please include the github issue or pull request url that has discussion related to your changes as a comment in the code example this greatly helps for project maintainability as it allows us to trace back use cases and explain decision making similarly please make sure that you meet all of the requirements listed in the pull request template please feel free to work on any open ticket especially any ticket marked with the help wanted label if you get stuck or want to discuss an issue further please join our slack channel where youll find a community of smart and interesting people working dilligently on hard problems zappa does not intend to conform to pep8 isolate your commits so that changes to functionality with changes made by your linter using a local repo to use the git head you probably cant use pip install e instead you should clone the repo to your machine and then pip install path to zappa repo or ln s path to zappa repo zappa zappa in your local project patrons if you or your company uses zappa please consider giving what you can to support the ongoing development of the project you can become a patron by visiting our patreon page zappa is currently supported by these awesome individuals and companies nathan lawrence launchlab sean paley theo chitayat george sibble joe weiss nik bora zerong toby wang gareth e matt jackson sean coates alexander loschilov korey peters joe weiss kimmo parvianen jalanko patrick agin roberto martinez charles dimino doug beney dan the man gayle juancito will childs klein efi merdler kravitz philippe trounev thank you very very much merch support development training consulting do you need help with porting existing flask and django applications to zappa building new applications and services that scale infinitely reducing your operations and hosting costs adding new custom features into zappa training your team to use aws and other server less paradigms good news were currently available for remote and on site consulting for small large and enterprise teams please contact miserlou gmail com with your needs and lets work together