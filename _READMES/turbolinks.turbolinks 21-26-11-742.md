turbolinks turbolinks® makes navigating your web application faster get the performance benefits of a single page application without the added complexity of a client side javascript framework use html to render your views on the server side and link to pages as usual when you follow a link turbolinks automatically fetches the page swaps in its body and merges its head all without incurring the cost of a full page load features optimizes navigation automatically no need to annotate links or specify which parts of the page should change no server side cooperation necessary respond with full html pages not partial page fragments or json respects the web the back and reload buttons work just as youd expect search engine friendly by design supports mobile apps adapters for ios and android let you build hybrid applications using native navigation controls supported browsers turbolinks works in all modern desktop and mobile browsers it depends on the html5 history api and window requestanimationframe in unsupported browsers turbolinks gracefully degrades to standard navigation installation include dist turbolinks js in your applications javascript bundle turbolinks automatically initializes itself when loaded via a standalone script tag or a traditional concatenated javascript bundle if you load turbolinks as a commonjs or amd module first require the module then call the provided start function installation using ruby on rails your ruby on rails application can use the turbolinks rubygem to install turbolinks this gem contains a rails engine which integrates seamlessly with the rails asset pipeline add the turbolinks gem version 5 to your gemfile gem turbolinks 5 1 0 run bundle install add require turbolinks to your javascript manifest file usually found at app assets javascripts application js the gem also provides server side support for turbolinks redirection which can be used without the asset pipeline installation using npm your application can use the turbolinks npm package to install turbolinks as a module for build tools like webpack add the turbolinks package to your application npm install save turbolinks require and start turbolinks in your javascript bundle js var turbolinks require turbolinks turbolinks start table of contents navigating with turbolinks each navigation is a visit application visits restoration visits canceling visits before they start disabling turbolinks on specific links building your turbolinks application working with script elements loading your applications javascript bundle understanding caching preparing the page to be cached detecting when a preview is visible opting out of caching installing javascript behavior observing navigation events attaching behavior with stimulus making transformations idempotent persisting elements across page loads advanced usage displaying progress reloading when assets change ensuring specific pages trigger a full reload setting a root location following redirects redirecting after a form submission setting custom http headers api reference turbolinks visit turbolinks clearcache turbolinks setprogressbardelay turbolinks supported full list of events contributing to turbolinks building from source running tests navigating with turbolinks turbolinks intercepts all clicks on a href links to the same domain when you click an eligible link turbolinks prevents the browser from following it instead turbolinks changes the browsers url using the history api requests the new page using xmlhttprequest and then renders the html response during rendering turbolinks replaces the current body element outright and merges the contents of the head element the javascript window and document objects and the html html element persist from one rendering to the next each navigation is a visit turbolinks models navigation as a visit to a location url with an action visits represent the entire navigation lifecycle from click to render that includes changing browser history issuing the network request restoring a copy of the page from cache rendering the final response and updating the scroll position there are two types of visit an application visit which has an action of advance or replace and a restoration visit which has an action of restore application visits application visits are initiated by clicking a turbolinks enabled link or programmatically by calling turbolinks visit location an application visit always issues a network request when the response arrives turbolinks renders its html and completes the visit if possible turbolinks will render a preview of the page from cache immediately after the visit starts this improves the perceived speed of frequent navigation between the same pages if the visits location includes an anchor turbolinks will attempt to scroll to the anchored element otherwise it will scroll to the top of the page application visits result in a change to the browsers history the visits action determines how the default visit action is advance during an advance visit turbolinks pushes a new entry onto the browsers history stack using history pushstate applications using the turbolinks ios adapter typically handle advance visits by pushing a new view controller onto the navigation stack similarly applications using the android adapter typically push a new activity onto the back stack you may wish to visit a location without pushing a new history entry onto the stack the replace visit action uses history replacestate to discard the topmost history entry and replace it with the new location to specify that following a link should trigger a replace visit annotate the link with data turbolinks action replace html a href edit data turbolinks action replace edit a to programmatically visit a location with the replace action pass the action replace option to turbolinks visit js turbolinks visit edit action replace applications using the turbolinks ios adapter typically handle replace visits by dismissing the topmost view controller and pushing a new view controller onto the navigation stack without animation restoration visits turbolinks automatically initiates a restoration visit when you navigate with the browsers back or forward buttons applications using the ios or android adapters initiate a restoration visit when moving backward in the navigation stack if possible turbolinks will render a copy of the page from cache without making a request otherwise it will retrieve a fresh copy of the page over the network see understanding caching for more details turbolinks saves the scroll position of each page before navigating away and automatically returns to this saved position on restoration visits restoration visits have an action of restore and turbolinks reserves them for internal use you should not attempt to annotate links or invoke turbolinks visit with an action of restore canceling visits before they start application visits can be canceled before they start regardless of whether they were initiated by a link click or a call to turbolinks visit listen for the turbolinks before visit event to be notified when a visit is about to start and use event data url or event originalevent data url when using jquery to check the visits location then cancel the visit by calling event preventdefault restoration visits cannot be canceled and do not fire turbolinks before visit turbolinks issues restoration visits in response to history navigation that has already taken place typically via the browsers back or forward buttons disabling turbolinks on specific links turbolinks can be disabled on a per link basis by annotating a link or any of its ancestors with data turbolinks false html disabled disabled to reenable when an ancestor has opted out use data turbolinks true html div data turbolinks false a href data turbolinks true enabled a div links with turbolinks disabled will be handled normally by the browser building your turbolinks application turbolinks is fast because it doesnt reload the page when you follow a link instead your application becomes a persistent long running process in the browser this requires you to rethink the way you structure your javascript in particular you can no longer depend on a full page load to reset your environment every time you navigate the javascript window and document objects retain their state across page changes and any other objects you leave in memory will stay in memory with awareness and a little extra care you can design your application to gracefully handle this constraint without tightly coupling it to turbolinks working with script elements your browser automatically loads and evaluates any script elements present on the initial page load when you navigate to a new page turbolinks looks for any script elements in the new pages head which arent present on the current page then it appends them to the current head where theyre loaded and evaluated by the browser you can use this to load additional javascript files on demand turbolinks evaluates script elements in a pages body each time it renders the page you can use inline body scripts to set up per page javascript state or bootstrap client side models to install behavior or to perform more complex operations when the page changes avoid script elements and use the turbolinks load event instead annotate script elements with data turbolinks eval false if you do not want turbolinks to evaluate them after rendering note that this annotation will not prevent your browser from evaluating scripts on the initial page load loading your applications javascript bundle always make sure to load your applications javascript bundle using script elements in the head of your document otherwise turbolinks will reload the bundle with every page change html head script src application cbd3cd4 js defer script head if you have traditionally placed application scripts at the end of body for performance reasons consider using the script defer attribute instead it has widespread browser support and allows you to keep your scripts in head for turbolinks compatibility you should also consider configuring your asset packaging system to fingerprint each script so it has a new url when its contents change then you can use the data turbolinks track attribute to force a full page reload when you deploy a new javascript bundle see reloading when assets change for information understanding caching turbolinks maintains a cache of recently visited pages this cache serves two purposes to display pages without accessing the network during restoration visits and to improve perceived performance by showing temporary previews during application visits when navigating by history via restoration visits turbolinks will restore the page from cache without loading a fresh copy from the network if possible otherwise during standard navigation via application visits turbolinks will immediately restore the page from cache and display it as a preview while simultaneously loading a fresh copy from the network this gives the illusion of instantaneous page loads for frequently accessed locations turbolinks saves a copy of the current page to its cache just before rendering a new page note that turbolinks copies the page using clonenode true which means any attached event listeners and associated data are discarded preparing the page to be cached listen for the turbolinks before cache event if you need to prepare the document before turbolinks caches it you can use this event to reset forms collapse expanded ui elements or tear down any third party widgets so the page is ready to be displayed again js document addeventlistener turbolinks before cache function detecting when a preview is visible turbolinks adds a data turbolinks preview attribute to the html element when it displays a preview from cache you can check for the presence of this attribute to selectively enable or disable behavior when a preview is visible js if document documentelement hasattribute data turbolinks preview turbolinks is displaying a preview opting out of caching you can control caching behavior on a per page basis by including a meta name turbolinks cache control element in your pages head and declaring a caching directive use the no preview directive to specify that a cached version of the page should not be shown as a preview during an application visit pages marked no preview will only be used for restoration visits to specify that a page should not be cached at all use the no cache directive pages marked no cache will always be fetched over the network including during restoration visits html head meta name turbolinks cache control content no cache head to completely disable caching in your application ensure every page contains a no cache directive installing javascript behavior you may be used to installing javascript behavior in response to the window onload domcontentloaded or jquery ready events with turbolinks these events will fire only in response to the initial page load not after any subsequent page changes we compare two strategies for connecting javascript behavior to the dom below observing navigation events turbolinks triggers a series of events during navigation the most significant of these is the turbolinks load event which fires once on the initial page load and again after every turbolinks visit you can observe the turbolinks load event in place of domcontentloaded to set up javascript behavior after every page change js document addeventlistener turbolinks load function keep in mind that your application will not always be in a pristine state when this event is fired and you may need to clean up behavior installed for the previous page also note that turbolinks navigation may not be the only source of page updates in your application so you may wish to move your initialization code into a separate function which you can call from turbolinks load and anywhere else you may change the dom when possible avoid using the turbolinks load event to add other event listeners directly to elements on the page body instead consider using event delegation to register event listeners once on document or window see the full list of events for more information attaching behavior with stimulus new dom elements can appear on the page at any time by way of ajax request handlers websocket handlers or client side rendering operations and these elements often need to be initialized as if they came from a fresh page load you can handle all of these updates including updates from turbolinks page loads in a single place with the conventions and lifecycle callbacks provided by turbolinks sister framework stimulus stimulus lets you annotate your html with controller action and target attributes html div data controller hello input data target hello name type text button data action click hello greet greet button div implement a compatible controller and stimulus connects it automatically js hello controller js import controller from stimulus export default class extends controller greet console log hello this name get name return this targets find name value stimulus connects and disconnects these controllers and their associated event handlers whenever the document changes using the mutationobserver api as a result it handles turbolinks page changes the same way it handles any other type of dom update see the stimulus repository on github for more information making transformations idempotent often youll want to perform client side transformations to html received from the server for example you might want to use the browsers knowledge of the users current time zone to group a collection of elements by date suppose you have annotated a set of elements with data timestamp attributes indicating the elements creation times in utc you have a javascript function that queries the document for all such elements converts the timestamps to local time and inserts date headers before each element that occurs on a new day consider what happens if youve configured this function to run on turbolinks load when you navigate to the page your function inserts date headers navigate away and turbolinks saves a copy of the transformed page to its cache now press the back button—turbolinks restores the page fires turbolinks load again and your function inserts a second set of date headers to avoid this problem make your transformation function idempotent an idempotent transformation is safe to apply multiple times without changing the result beyond its initial application one technique for making a transformation idempotent is to keep track of whether youve already performed it by setting a data attribute on each processed element when turbolinks restores your page from cache these attributes will still be present detect these attributes in your transformation function to determine which elements have already been processed a more robust technique is simply to detect the transformation itself in the date grouping example above that means checking for the presence of a date divider before inserting a new one this approach gracefully handles newly inserted elements that werent processed by the original transformation persisting elements across page loads turbolinks allows you to mark certain elements as permanent permanent elements persist across page loads so that any changes you make to those elements do not need to be reapplied after navigation consider a turbolinks application with a shopping cart at the top of each page is an icon with the number of items currently in the cart this counter is updated dynamically with javascript as items are added and removed now imagine a user who has navigated to several pages in this application she adds an item to her cart then presses the back button in her browser upon navigation turbolinks restores the previous pages state from cache and the cart item count erroneously changes from 1 to 0 you can avoid this problem by marking the counter element as permanent designate permanent elements by giving them an html id and annotating them with data turbolinks permanent html div id cart counter data turbolinks permanent 1 item div before each render turbolinks matches all permanent elements by id and transfers them from the original page to the new page preserving their data and event listeners advanced usage displaying progress during turbolinks navigation the browser will not display its native progress indicator turbolinks installs a css based progress bar to provide feedback while issuing a request the progress bar is enabled by default it appears automatically for any page that takes longer than 500ms to load you can change this delay with the turbolinks setprogressbardelay method the progress bar is a div element with the class name turbolinks progress bar its default styles appear first in the document and can be overridden by rules that come later for example the following css will result in a thick green progress bar css turbolinks progress bar height 5px background color green to disable the progress bar entirely set its visibility style to hidden css turbolinks progress bar visibility hidden reloading when assets change turbolinks can track the urls of asset elements in head from one page to the next and automatically issue a full reload if they change this ensures that users always have the latest versions of your applications scripts and styles annotate asset elements with data turbolinks track reload and include a version identifier in your asset urls the identifier could be a number a last modified timestamp or better a digest of the assets contents as in the following example html head link rel stylesheet href application 258e88d css data turbolinks track reload script src application cbd3cd4 js data turbolinks track reload script head ensuring specific pages trigger a full reload you can ensure visits to a certain page will always trigger a full reload by including a meta name turbolinks visit control element in the pages head html head meta name turbolinks visit control content reload head this setting may be useful as a workaround for third party javascript libraries that dont interact well with turbolinks page changes setting a root location by default turbolinks only loads urls with the same origin—i e the same protocol domain name and port—as the current document a visit to any other url falls back to a full page load in some cases you may want to further scope turbolinks to a path on the same origin for example if your turbolinks application lives at app and the non turbolinks help site lives at help links from the app to the help site shouldnt use turbolinks include a meta name turbolinks root element in your pages head to scope turbolinks to a particular root location turbolinks will only load same origin urls that are prefixed with this path html head meta name turbolinks root content app head following redirects when you visit location one and the server redirects you to location two you expect the browsers address bar to display the redirected url however turbolinks makes requests using xmlhttprequest which transparently follows redirects theres no way for turbolinks to tell whether a request resulted in a redirect without additional cooperation from the server to work around this problem send the turbolinks location header in response to a visit that was redirected and turbolinks will replace the browsers topmost history entry with the value you provide the turbolinks rails engine sets turbolinks location automatically when using redirect to in response to a turbolinks visit redirecting after a form submission submitting an html form to the server and redirecting in response is a common pattern in web applications standard form submission is similar to navigation resulting in a full page load using turbolinks you can improve the performance of form submission without complicating your server side code instead of submitting forms normally submit them with xhr in response to an xhr submit on the server return javascript that performs a turbolinks visit to be evaluated by the browser if form submission results in a state change on the server that affects cached pages consider clearing turbolinks cache with turbolinks clearcache the turbolinks rails engine performs this optimization automatically for non get xhr requests that redirect with the redirect to helper setting custom http headers you can observe the turbolinks request start event to set custom headers on turbolinks requests access the requests xmlhttprequest object via event data xhr then call the setrequestheader method as many times as you wish for example you might want to include a request id with every turbolinks link click and programmatic visit javascript document addeventlistener turbolinks request start function event var xhr event data xhr xhr setrequestheader x request id 123 api reference turbolinks visit usage js turbolinks visit location turbolinks visit location action action performs an application visit to the given location a string containing a url or path with the specified action a string either advance or replace if location is a cross origin url or falls outside of the specified root see setting a root location or if the value of turbolinks supported is false turbolinks performs a full page load by setting window location if action is unspecified turbolinks assumes a value of advance before performing the visit turbolinks fires a turbolinks before visit event on document your application can listen for this event and cancel the visit with event preventdefault see canceling visits before they start turbolinks clearcache usage js turbolinks clearcache removes all entries from the turbolinks page cache call this when state has changed on the server that may affect cached pages turbolinks setprogressbardelay usage js turbolinks setprogressbardelay delayinmilliseconds sets the delay after which the progress bar will appear during navigation in milliseconds the progress bar appears after 500ms by default note that this method has no effect when used with the ios or android adapters turbolinks supported usage js if turbolinks supported detects whether turbolinks is supported in the current browser see supported browsers full list of events turbolinks emits events that allow you to track the navigation lifecycle and respond to page loading except where noted turbolinks fires events on the document object turbolinks click fires when you click a turbolinks enabled link the clicked element is the event target access the requested location with event data url cancel this event to let the click fall through to the browser as normal navigation turbolinks before visit fires before visiting a location except when navigating by history access the requested location with event data url cancel this event to prevent navigation turbolinks visit fires immediately after a visit starts turbolinks request start fires before turbolinks issues a network request to fetch the page access the xmlhttprequest object with event data xhr turbolinks request end fires after the network request completes access the xmlhttprequest object with event data xhr turbolinks before cache fires before turbolinks saves the current page to cache turbolinks before render fires before rendering the page access the new body element with event data newbody turbolinks render fires after turbolinks renders the page this event fires twice during an application visit to a cached location once after rendering the cached version and again after rendering the fresh version turbolinks load fires once after the initial page load and again after every turbolinks visit access visit timing metrics with the event data timing object contributing to turbolinks turbolinks is open source software freely distributable under the terms of an mit style license the source code is hosted on github development is sponsored by basecamp we welcome contributions in the form of bug reports pull requests or thoughtful discussions in the github issue tracker please note that this project is released with a contributor code of conduct by participating in this project you agree to abide by its terms building from source turbolinks is written in coffeescript and compiled to javascript with blade to build from source youll need a recent version of ruby from the root of your turbolinks directory issue the following commands to build the distributable files in dist gem install bundler bundle install bin blade build running tests follow the instructions for building from source above then run bin blade runner and visit the displayed url in your browser the turbolinks test suite will start automatically © 2018 basecamp llc